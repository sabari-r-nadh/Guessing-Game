"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[460],{70606:function(e,t,s){var n,i=s(38891).Buffer,a=this&&this.__decorate||function(e,t,s,n){var i,a=arguments.length,o=a<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,s):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,s,n);else for(var c=e.length-1;c>=0;c--)(i=e[c])&&(o=(a<3?i(o):a>3?i(t,s,o):i(t,s))||o);return a>3&&o&&Object.defineProperty(t,s,o),o};Object.defineProperty(t,"__esModule",{value:!0}),t.AuthenticationService=void 0;const o=s(43640),c=s(72101),r=s(76994),u=s(32003),h=s(80260),l=s(30919),d=s(18006),g=s(38762),y=s(65250),w=s(98149),v=s(22653);let A=n=class extends o.SshService{constructor(e){var t;super(e),this.currentRequestMessage=null,this.authenticationFailureCount=0,this.disposeCancellationSource=new r.CancellationTokenSource;const s=null===(t=e.algorithms)||void 0===t?void 0:t.publicKeyAlgorithmName;if(!s)throw new Error("Algorithms not initialized.");this.publicKeyAlgorithmName=s}handleMessage(e,t){return e instanceof c.AuthenticationSuccessMessage?this.handleSuccessMessage(e):e instanceof c.AuthenticationFailureMessage?this.handleFailureMessage(e):e instanceof c.AuthenticationRequestMessage?this.handleAuthenticationRequestMessage(e,t):e instanceof c.AuthenticationInfoRequestMessage?this.handleInfoRequestMessage(e,t):e instanceof c.AuthenticationInfoResponseMessage?this.handleInfoResponseMessage(e,t):void c.PublicKeyOKMessage}async handleAuthenticationRequestMessage(e,t){this.trace(w.TraceLevel.Info,w.SshTraceEventIds.sessionAuthenticating,`Authentication request: ${e.methodName}`);let s=e.methodName;if(this.session.config.authenticationMethods.includes(s)||(s=null),"publickey"===s||"hostbased"===s){const s=e.convertTo(new c.PublicKeyRequestMessage);return this.setCurrentRequest(s),this.handlePublicKeyRequestMessage(s,t)}if("password"===s){const s=e.convertTo(new c.PasswordRequestMessage);return this.setCurrentRequest(s),this.handlePasswordRequestMessage(s,t)}if("keyboard-interactive"===s)return this.setCurrentRequest(e),this.beginInteractiveAuthentication(e,t);if("none"===s)return this.setCurrentRequest(e),this.handleAuthenticating(new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientNone,{username:e.username}),t);{this.setCurrentRequest(null);const e=new c.AuthenticationFailureMessage;e.methodNames=["publickey","password","hostbased"],await this.session.sendMessage(e,t)}}setCurrentRequest(e){var t;this.currentRequestMessage=e;const s=this.session.protocol;s&&(s.messageContext=null!==(t=null==e?void 0:e.methodName)&&void 0!==t?t:null)}async handlePublicKeyRequestMessage(e,t){var s,n,a;const o=this.session.config.getPublicKeyAlgorithm(e.keyAlgorithmName);if(!o){const e=new c.AuthenticationFailureMessage;return e.methodNames=["publickey","password"],void await this.session.sendMessage(e,t)}const r=o.createKeyPair();let h;if(await r.setPublicKeyBytes(e.publicKey),"hostbased"===e.methodName)h=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientHostBased,{username:null!==(s=e.username)&&void 0!==s?s:"",publicKey:r,clientHostname:e.clientHostname,clientUsername:e.clientUsername});else if(e.hasSignature){const s=o.readSignatureData(e.signature),n=this.session.sessionId;if(null==n)throw new Error("Session ID not initialized.");const c=new u.SshDataWriter(i.alloc(n.length+e.payloadWithoutSignature.length+20));c.writeBinary(n),c.write(e.payloadWithoutSignature);const d=c.toBuffer(),g=o.createVerifier(r);await g.verify(d,s)||await this.handleAuthenticationFailure("Public key authentication failed: invalid signature.",t),h=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientPublicKey,{username:null!==(a=e.username)&&void 0!==a?a:"",publicKey:r})}else h=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientPublicKeyQuery,{username:null!==(n=e.username)&&void 0!==n?n:"",publicKey:r});await this.handleAuthenticating(h,t)}async handlePasswordRequestMessage(e,t){var s,n;const i=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientPassword,{username:null!==(s=e.username)&&void 0!==s?s:"",password:null!==(n=e.password)&&void 0!==n?n:""});await this.handleAuthenticating(i,t)}async beginInteractiveAuthentication(e,t){const s=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientInteractive,{username:e.username});await this.handleAuthenticating(s,t)}async handleInfoRequestMessage(e,t){const s=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientInteractive,{infoRequest:e});await this.handleAuthenticating(s,t)}async handleInfoResponseMessage(e,t){var s;const n=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientInteractive,{username:null===(s=this.currentRequestMessage)||void 0===s?void 0:s.username,infoResponse:e});await this.handleAuthenticating(n,t)}async handleAuthenticating(e,t){var s;if(!this.currentRequestMessage)throw new v.SshConnectionError("No current authentication request.",h.SshDisconnectReason.protocolError);e.cancellation=this.disposeCancellationSource.token;let n=null;try{n=await this.session.raiseAuthenticatingEvent(e)}catch(e){if(!(e instanceof Error))throw e;this.trace(w.TraceLevel.Error,w.SshTraceEventIds.authenticationError,`Error while authenticating client: ${e.message}`,e),n=null}if(n)if(e.authenticationType===l.SshAuthenticationType.clientPublicKeyQuery){const e=this.currentRequestMessage,s=new c.PublicKeyOKMessage;s.keyAlgorithmName=e.keyAlgorithmName,s.publicKey=e.publicKey,this.setCurrentRequest(null),await this.session.sendMessage(s,t)}else{this.session.principal=n;const i=this.currentRequestMessage.serviceName;i&&this.session.activateService(i),this.trace(w.TraceLevel.Info,w.SshTraceEventIds.sessionAuthenticated,`${l.SshAuthenticationType[e.authenticationType]} authentication succeeded.`),this.setCurrentRequest(null),await this.session.sendMessage(new c.AuthenticationSuccessMessage,t),null===(s=this.session)||void 0===s||s.handleClientAuthenticated()}else e.authenticationType===l.SshAuthenticationType.clientInteractive&&!this.session.isClientSession&&e.infoRequest?await this.sendMessage(e.infoRequest,t):e.authenticationType===l.SshAuthenticationType.clientInteractive&&this.session.isClientSession&&e.infoResponse?await this.sendMessage(e.infoResponse,t):(this.setCurrentRequest(null),await this.handleAuthenticationFailure(`${l.SshAuthenticationType[e.authenticationType]} authentication failed.`))}async handleAuthenticationFailure(e,t){this.authenticationFailureCount++,this.trace(w.TraceLevel.Warning,w.SshTraceEventIds.clientAuthenticationFailed,e);const s=new c.AuthenticationFailureMessage;s.methodNames=this.session.config.authenticationMethods,await this.session.sendMessage(s,t),this.authenticationFailureCount>=this.session.config.maxClientAuthenticationAttempts&&await this.session.close(h.SshDisconnectReason.noMoreAuthMethodsAvailable,"Authentication failed.")}async authenticateClient(e,t){var s,n,i,a;this.clientAuthenticationMethods=new y.Queue;const o=this.session.config.authenticationMethods;if(o.includes("publickey"))for(const t of null!==(s=e.publicKeys)&&void 0!==s?s:[]){if(!t)continue;const s=null!==(n=e.username)&&void 0!==n?n:"";let i=t;const a=e.privateKeyProvider;this.clientAuthenticationMethods.enqueue({method:"publickey",handler:async e=>{if(!i.hasPrivateKey){if(null==a)throw new Error("A private key provider is required.");i=await a(t,null!=e?e:r.CancellationToken.None)}i?await this.requestPublicKeyAuthentication(s,i,e):await this.session.close(h.SshDisconnectReason.authCancelledByUser)}})}if(o.includes("password")){const t=e.passwordProvider;if(t)this.clientAuthenticationMethods.enqueue({method:"password",handler:async e=>{var s;const n=t(null!=e?e:r.CancellationToken.None),i=n?await n:null;i?await this.requestPasswordAuthentication(null!==(s=i[0])&&void 0!==s?s:"",i[1],e):await this.session.close(h.SshDisconnectReason.authCancelledByUser)}});else if(e.password){const t=null!==(i=e.username)&&void 0!==i?i:"",s=e.password;this.clientAuthenticationMethods.enqueue({method:"password",handler:async e=>{await this.requestPasswordAuthentication(t,s,e)}})}}if(0===this.clientAuthenticationMethods.size){const t=null!==(a=e.username)&&void 0!==a?a:"";if(o.includes("none")&&this.clientAuthenticationMethods.enqueue({method:"none",handler:async e=>{await this.requestUsernameAuthentication(t,e)}}),o.includes("keyboard-interactive")&&this.clientAuthenticationMethods.enqueue({method:"keyboard-interactive",handler:async e=>{await this.requestInteractiveAuthentication(t,e)}}),0===this.clientAuthenticationMethods.size)throw new Error("Could not prepare request for authentication method(s): "+o.join(", ")+". Supply client credentials or enable none or interactive authentication methods.")}this.session.activateService(d.ConnectionService);const c=this.clientAuthenticationMethods.dequeue();await c.handler(t)}async requestUsernameAuthentication(e,t){const s=new c.AuthenticationRequestMessage;s.serviceName=d.ConnectionService.serviceName,s.methodName="none",s.username=e,this.setCurrentRequest(s),await this.session.sendMessage(s,t)}async requestPublicKeyAuthentication(e,t,s){const n=this.session.config.publicKeyAlgorithms.find((e=>(null==e?void 0:e.keyAlgorithmName)===t.keyAlgorithmName));if(!n)throw new Error(`Public key algorithm '${t.keyAlgorithmName}' is not in session config.`);const i=new c.PublicKeyRequestMessage;i.serviceName=d.ConnectionService.serviceName,i.username=e,i.keyAlgorithmName=n.name,i.publicKey=await t.getPublicKeyBytes(n.name),i.signature=await this.createAuthenticationSignature(i,n,t),this.setCurrentRequest(i),await this.session.sendMessage(i,s)}async requestPasswordAuthentication(e,t,s){const n=new c.PasswordRequestMessage;n.serviceName=d.ConnectionService.serviceName,n.username=e,n.password=t,this.setCurrentRequest(n),await this.session.sendMessage(n,s)}async requestInteractiveAuthentication(e,t){const s=new c.AuthenticationRequestMessage;s.serviceName=d.ConnectionService.serviceName,s.methodName="keyboard-interactive",s.username=e,this.setCurrentRequest(s),await this.session.sendMessage(s,t)}async handleFailureMessage(e){var t,s;for(this.setCurrentRequest(null);null===(t=this.clientAuthenticationMethods)||void 0===t?void 0:t.size;){const t=this.clientAuthenticationMethods.dequeue();if(null===(s=e.methodNames)||void 0===s?void 0:s.includes(t.method))return void await t.handler(this.disposeCancellationSource.token)}this.session.onAuthenticationComplete(!1)}handleSuccessMessage(e){this.setCurrentRequest(null),this.session.onAuthenticationComplete(!0)}async createAuthenticationSignature(e,t,s){const n=this.session.sessionId;if(null==n)throw new Error("Session ID not initialized.");const a=new u.SshDataWriter(i.alloc(e.publicKey.length+(e.username||"").length+400));a.writeBinary(n),a.writeByte(e.messageType),a.writeString(e.username||"","utf8"),a.writeString(e.serviceName||"","ascii"),a.writeString("publickey","ascii"),a.writeBoolean(!0),a.writeString(e.keyAlgorithmName,"ascii"),a.writeBinary(e.publicKey);const o=t.createSigner(s),c=await o.sign(a.toBuffer());return t.createSignatureData(c)}dispose(){try{this.disposeCancellationSource.cancel(),this.disposeCancellationSource.dispose()}catch(e){}super.dispose()}};A.serviceName="ssh-userauth",A=n=a([(0,g.serviceActivation)({serviceRequest:n.serviceName})],A),t.AuthenticationService=A}}]);