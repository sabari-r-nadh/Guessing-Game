"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[94],{82116:function(e,t,i){var n,s=this&&this.__decorate||function(e,t,i,n){var s,o=arguments.length,r=o<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(e,t,i,n);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(r=(o<3?s(r):o>3?s(t,i,r):s(t,i))||r);return o>3&&r&&Object.defineProperty(t,i,r),r};Object.defineProperty(t,"__esModule",{value:!0}),t.KeyExchangeService=void 0;const o=i(38891),r=i(62036),a=i(43640),h=i(1138),c=i(16101),l=i(37179),g=i(32003),x=i(22653),y=i(80260),m=i(4030),u=i(76994),d=i(18006),f=i(38762),v=i(98149);class C{}const p="ext-info-s",w="ext-info-c";let E=n=class extends a.SshService{constructor(e){super(e),this.isInitialExchange=!1,this.exchangeContext=null}get exchanging(){return!!this.exchangeContext}async startKeyExchange(e){this.isInitialExchange=e,this.exchangeContext=new C;const t=this.createKeyExchangeInitMessage();let i=null;return this.session.isClientSession?(e&&this.session.config.enableKeyExchangeGuess&&(i=await this.createKeyExchangeGuessMessage(),t.firstKexPacketFollows=!!i),this.exchangeContext.clientKexInitPayload=t.toBuffer()):this.exchangeContext.serverKexInitPayload=t.toBuffer(),[t,i]}finishKeyExchange(){var e;if(!this.exchangeContext)throw new x.SshConnectionError("Key exchange not started.",y.SshDisconnectReason.protocolError);const t=this.exchangeContext.newAlgorithms;if(!t)throw new x.SshConnectionError("Key exchange not completed.",y.SshDisconnectReason.protocolError);return t.isExtensionInfoRequested=null===(e=this.exchangeContext)||void 0===e?void 0:e.isExtensionInfoRequested,this.exchangeContext=null,t}abortKeyExchange(){this.exchangeContext=null}createKeyExchangeInitMessage(){const e=this.session.isClientSession?w:p,t=this.session.config,i=new c.KeyExchangeInitMessage;return i.keyExchangeAlgorithms=(0,l.algorithmNames)(t.keyExchangeAlgorithms).concat(e),i.serverHostKeyAlgorithms=this.getPublicKeyAlgorithms(),i.encryptionAlgorithmsClientToServer=i.encryptionAlgorithmsServerToClient=(0,l.algorithmNames)(t.encryptionAlgorithms),i.macAlgorithmsClientToServer=i.macAlgorithmsServerToClient=(0,l.algorithmNames)(t.hmacAlgorithms),i.compressionAlgorithmsClientToServer=i.compressionAlgorithmsServerToClient=(0,l.algorithmNames)(t.compressionAlgorithms),i.languagesClientToServer=[""],i.languagesServerToClient=[""],i.firstKexPacketFollows=!1,i.reserved=0,i}getPublicKeyAlgorithms(){var e,t;let i=[...this.session.config.publicKeyAlgorithms];if(i.length>1&&!this.session.isClientSession){const n=null===(t=null===(e=this.session.credentials)||void 0===e?void 0:e.publicKeys)||void 0===t?void 0:t.map((e=>e.keyAlgorithmName));n&&(i=i.filter((e=>e&&n.includes(e.keyAlgorithmName))))}return(0,l.algorithmNames)(i)}async createKeyExchangeGuessMessage(){if(!this.exchangeContext)throw new Error("Key exchange was not started.");const e=this.session.config.keyExchangeAlgorithms[0];if(!e)return null;this.exchangeContext.keyExchange=e.name,this.exchangeContext.exchange=e.createKeyExchange(),this.exchangeContext.exchangeValue=await this.exchangeContext.exchange.startKeyExchange();const t=new c.KeyExchangeDhInitMessage;return t.e=this.exchangeContext.exchangeValue,t}handleMessage(e,t){if(e instanceof c.KeyExchangeInitMessage)return this.handleInitMessage(e,t);if(e instanceof c.KeyExchangeDhInitMessage)return this.handleDhInitMessage(e,t);if(e instanceof c.KeyExchangeDhReplyMessage)return this.handleDhReplyMessage(e,t);throw new Error(`Message not implemented: ${e}`)}async handleInitMessage(e,t){var i,n,s,o;if(!this.exchangeContext)throw new Error("Key exchange was not started.");const r=this.session.config;if(this.exchangeContext.keyExchange=this.chooseAlgorithm("KeyExchange",(0,l.algorithmNames)(r.keyExchangeAlgorithms),e.keyExchangeAlgorithms),"none"===this.exchangeContext.keyExchange)return this.trace(v.TraceLevel.Info,v.SshTraceEventIds.algorithmNegotiation,"Client and server negotiated no security. Cancelling key-exchange."),this.session.activateService(d.ConnectionService),this.exchangeContext.newAlgorithms=new m.SshSessionAlgorithms,void await this.session.handleNewKeysMessage(new c.NewKeysMessage,t);if(this.exchangeContext.publicKey=this.chooseAlgorithm("PublicKey",this.getPublicKeyAlgorithms(),e.serverHostKeyAlgorithms),this.exchangeContext.clientEncryption=this.chooseAlgorithm("ClientEncryption",(0,l.algorithmNames)(r.encryptionAlgorithms),e.encryptionAlgorithmsClientToServer),this.exchangeContext.serverEncryption=this.chooseAlgorithm("ServerEncryption",(0,l.algorithmNames)(r.encryptionAlgorithms),e.encryptionAlgorithmsServerToClient),this.exchangeContext.clientHmac=this.chooseAlgorithm("ClientHmac",(0,l.algorithmNames)(r.hmacAlgorithms),e.macAlgorithmsClientToServer),this.exchangeContext.serverHmac=this.chooseAlgorithm("ServerHmac",(0,l.algorithmNames)(r.hmacAlgorithms),e.macAlgorithmsServerToClient),this.exchangeContext.clientCompression=this.chooseAlgorithm("ClientCompression",(0,l.algorithmNames)(r.compressionAlgorithms),e.compressionAlgorithmsClientToServer),this.exchangeContext.serverCompression=this.chooseAlgorithm("ServerCompression",(0,l.algorithmNames)(r.compressionAlgorithms),e.compressionAlgorithmsServerToClient),this.session.isClientSession){this.exchangeContext.serverKexInitPayload=e.toBuffer();const s=!!this.exchangeContext.exchangeValue,o=this.exchangeContext.keyExchange===(null===(i=r.keyExchangeAlgorithms[0])||void 0===i?void 0:i.name);if(s&&o)this.trace(v.TraceLevel.Verbose,v.SshTraceEventIds.algorithmNegotiation,"Already sent correct guess for key-exchange init.");else{const e=r.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);this.exchangeContext.exchange=e.createKeyExchange(),this.exchangeContext.exchangeValue=await this.exchangeContext.exchange.startKeyExchange();const i=new c.KeyExchangeDhInitMessage;i.e=this.exchangeContext.exchangeValue,await this.session.sendMessage(i,t)}this.exchangeContext.isExtensionInfoRequested=this.isInitialExchange&&(null===(n=e.keyExchangeAlgorithms)||void 0===n?void 0:n.includes(p))}else{if(e.firstKexPacketFollows){const t=this.exchangeContext.keyExchange===(null===(s=e.keyExchangeAlgorithms)||void 0===s?void 0:s[0]),i=t?"correct":"incorrect";this.trace(v.TraceLevel.Verbose,v.SshTraceEventIds.algorithmNegotiation,`Client's KeyExchange guess was ${i}.`),this.exchangeContext.discardGuessedInit=!t}this.exchangeContext.clientKexInitPayload=e.toBuffer(),this.exchangeContext.isExtensionInfoRequested=this.isInitialExchange&&(null===(o=e.keyExchangeAlgorithms)||void 0===o?void 0:o.includes(w))}}async handleDhInitMessage(e,t){var i,n,s,r,a;if(this.session.isClientSession)return;const h=this.session;if(!this.exchangeContext||!this.exchangeContext.keyExchange||!this.exchangeContext.publicKey)throw new x.SshConnectionError("Key exchange not started.",y.SshDisconnectReason.protocolError);if(this.exchangeContext.discardGuessedInit)return void(this.exchangeContext.discardGuessedInit=!1);const l=this.session.config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);if(!l)throw new x.SshConnectionError("Key exchange not supported for algorithm: "+this.exchangeContext.keyExchange,y.SshDisconnectReason.keyExchangeFailed);const g=this.session.config.getPublicKeyAlgorithm(this.exchangeContext.publicKey);if(!g)throw new x.SshConnectionError("Public key algorithm not supported: "+this.exchangeContext.publicKey,y.SshDisconnectReason.keyExchangeFailed);let d=null;if(null===(i=h.credentials)||void 0===i?void 0:i.publicKeys){const e=h.credentials.publicKeys.find((e=>e.keyAlgorithmName===g.keyAlgorithmName));if(d=null!=e?e:null,!1===(null==d?void 0:d.hasPrivateKey)){if(!h.credentials.privateKeyProvider)throw new Error("A private key provider is required.");d=await h.credentials.privateKeyProvider(e,null!=t?t:u.CancellationToken.None)}}if(null==d)throw new x.SshConnectionError("Private key not found for algorithm: "+this.exchangeContext.publicKey,y.SshDisconnectReason.keyExchangeFailed);const f=this.session.config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption),v=this.session.config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption),C=this.session.config.getHmacAlgorithm(this.exchangeContext.serverHmac),p=this.session.config.getHmacAlgorithm(this.exchangeContext.clientHmac),w=l.createKeyExchange(),E=e.e||o.Buffer.alloc(0),K=await w.startKeyExchange(),S=await w.decryptKeyExchange(E),A=await d.getPublicKeyBytes(g.name);if(!A)throw new x.SshConnectionError("Public key not set.",y.SshDisconnectReason.keyExchangeFailed);const k=await this.computeExchangeHash(w,A,E,K,S);this.session.sessionId||(this.session.sessionId=k);const[I,b,N,M,T,B]=await this.computeKeys(w,S,k,f,v,p,C),D=null!==(n=await(null==v?void 0:v.createCipher(!0,M,b)))&&void 0!==n?n:null,P=null!==(s=await(null==f?void 0:f.createCipher(!1,N,I)))&&void 0!==s?s:null,R=null!==(r=await(null==C?void 0:C.createSigner(B)))&&void 0!==r?r:null,V=null!==(a=await(null==p?void 0:p.createVerifier(T)))&&void 0!==a?a:null,H=new m.SshSessionAlgorithms;H.publicKeyAlgorithmName=this.exchangeContext.publicKey,H.cipher=D,H.decipher=P,H.signer=R,H.verifier=V,H.messageSigner=(null==D?void 0:D.authenticatedEncryption)?D:R,H.messageVerifier=(null==P?void 0:P.authenticatedEncryption)?P:V,H.compressor=this.session.config.getCompressionAlgorithm(this.exchangeContext.serverCompression),H.decompressor=this.session.config.getCompressionAlgorithm(this.exchangeContext.clientCompression),this.exchangeContext.newAlgorithms=H,I&&I.fill(0),N&&N.fill(0),T&&T.fill(0),b&&b.fill(0),M&&M.fill(0),B&&B.fill(0);const L=g.createSigner(d);let F=await L.sign(k);F=g.createSignatureData(F);const $=new c.KeyExchangeDhReplyMessage;$.hostKey=A,$.f=K,$.signature=F,await this.session.sendMessage($,t),await this.session.sendMessage(new c.NewKeysMessage,t)}async handleDhReplyMessage(e,t){var i,n,s,o;if(!this.session.isClientSession)return;if(!this.exchangeContext)throw new x.SshConnectionError("Key exchange was not started.",y.SshDisconnectReason.protocolError);const r=this.session.config,a=this.exchangeContext.exchange,h=this.exchangeContext.publicKey,l=r.getPublicKeyAlgorithm(h),g=r.getEncryptionAlgorithm(this.exchangeContext.clientEncryption),u=r.getEncryptionAlgorithm(this.exchangeContext.serverEncryption),d=r.getHmacAlgorithm(this.exchangeContext.serverHmac),f=r.getHmacAlgorithm(this.exchangeContext.clientHmac),C=this.exchangeContext.exchangeValue,p=e.f;if(!a||!C)throw new x.SshConnectionError("Failed to initialize crypto after key exchange.",y.SshDisconnectReason.keyExchangeFailed);this.hostKey=l.createKeyPair(),await this.hostKey.setPublicKeyBytes(e.hostKey);const w=await a.decryptKeyExchange(p),E=e.hostKey,K=await this.computeExchangeHash(a,E,C,p,w),S=l.readSignatureData(e.signature),A=l.createVerifier(this.hostKey);let k;try{k=await A.verify(K,S)}catch(e){if(!(e instanceof Error))throw e;throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.serverAuthenticationFailed,`Server public key verification error: ${e.message}`,e),new x.SshConnectionError(`Server public key verification failed: ${e.message}`,y.SshDisconnectReason.hostKeyNotVerifiable)}if(!k)throw this.trace(v.TraceLevel.Warning,v.SshTraceEventIds.serverAuthenticationFailed,"Server public key verification failed."),new x.SshConnectionError("Server public key verification failed.",y.SshDisconnectReason.hostKeyNotVerifiable);this.trace(v.TraceLevel.Verbose,v.SshTraceEventIds.sessionAuthenticated,"Server public key verification succeeded."),null==this.session.sessionId&&(this.session.sessionId=K);const[I,b,N,M,T,B]=await this.computeKeys(a,w,K,g,u,f,d),D=null!==(i=await(null==g?void 0:g.createCipher(!0,N,I)))&&void 0!==i?i:null,P=null!==(n=await(null==u?void 0:u.createCipher(!1,M,b)))&&void 0!==n?n:null,R=null!==(s=await(null==f?void 0:f.createSigner(T)))&&void 0!==s?s:null,V=null!==(o=await(null==d?void 0:d.createVerifier(B)))&&void 0!==o?o:null,H=new m.SshSessionAlgorithms;H.publicKeyAlgorithmName=h,H.cipher=D,H.decipher=P,H.signer=R,H.verifier=V,H.messageSigner=(null==D?void 0:D.authenticatedEncryption)?D:R,H.messageVerifier=(null==P?void 0:P.authenticatedEncryption)?P:V,H.compressor=r.getCompressionAlgorithm(this.exchangeContext.clientCompression),H.decompressor=r.getCompressionAlgorithm(this.exchangeContext.serverCompression),this.exchangeContext.newAlgorithms=H,I&&I.fill(0),N&&N.fill(0),T&&T.fill(0),b&&b.fill(0),M&&M.fill(0),B&&B.fill(0),await this.session.sendMessage(new c.NewKeysMessage,t)}chooseAlgorithm(e,t,i){let n,s;this.session.isClientSession?(n=i||[],s=t):(n=t,s=i||[]);const o=`${e} negotiation: Server (${n.join(", ")}) Client (${s.join(", ")})`;for(const e of s)for(const t of n)if(t===e){const e=t;return this.trace(v.TraceLevel.Info,v.SshTraceEventIds.algorithmNegotiation,`${o} => ${e}`),e}throw new Error(`Failed ${o}`)}async computeExchangeHash(e,t,i,n,s){if(!this.session.remoteVersion)throw new Error("Key exchange not completed.");const a=new g.SshDataWriter(o.Buffer.alloc(2048));this.session.isClientSession?(a.writeString(r.SshSession.localVersion.toString(),"ascii"),a.writeString(this.session.remoteVersion.toString(),"ascii")):(a.writeString(this.session.remoteVersion.toString(),"ascii"),a.writeString(r.SshSession.localVersion.toString(),"ascii")),a.writeBinary(this.exchangeContext.clientKexInitPayload),a.writeBinary(this.exchangeContext.serverKexInitPayload),a.writeBinary(t),a.writeBigInt(h.BigInt.fromBytes(i,{unsigned:!0})),a.writeBigInt(h.BigInt.fromBytes(n,{unsigned:!0})),a.writeBigInt(h.BigInt.fromBytes(s,{unsigned:!0}));return await e.sign(a.toBuffer())}async computeKeys(e,t,i,n,s,r,a){var h,c;const l=new g.SshDataWriter(o.Buffer.alloc(4+t.length+i.length+Math.max(1+(null!==(c=null===(h=this.session.sessionId)||void 0===h?void 0:h.length)&&void 0!==c?c:0),e.digestLength)));l.writeBinary(t),l.write(i);const x=l.position;return[n&&await this.computeKey(e,l,x,n.blockLength,"A"),s&&await this.computeKey(e,l,x,s.blockLength,"B"),n&&await this.computeKey(e,l,x,n.keyLength,"C"),s&&await this.computeKey(e,l,x,s.keyLength,"D"),r&&await this.computeKey(e,l,x,r.keyLength,"E"),a&&await this.computeKey(e,l,x,a.keyLength,"F")]}async computeKey(e,t,i,n,s){const r=o.Buffer.alloc(n);let a=0,h=0,c=null;if(!this.session.sessionId)throw new Error("Session ID not set.");for(;a<n;)t.position=i,c?t.write(c):(t.writeByte(s.charCodeAt(0)),t.write(this.session.sessionId)),c=await e.sign(t.toBuffer()),h=Math.min(c.length,n-a),c.copy(r,a),a+=h;return c&&c.fill(0),r}};E.serviceName="ssh-keyexchange",E=n=s([(0,f.serviceActivation)({serviceRequest:n.serviceName})],E),t.KeyExchangeService=E}}]);