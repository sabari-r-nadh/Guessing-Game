"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[240],{85328:function(e,r,o){var t,s=this&&this.__decorate||function(e,r,o,t){var s,n=arguments.length,a=n<3?r:null===t?t=Object.getOwnPropertyDescriptor(r,o):t;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,r,o,t);else for(var i=e.length-1;i>=0;i--)(s=e[i])&&(a=(n<3?s(a):n>3?s(r,o,a):s(r,o))||a);return n>3&&a&&Object.defineProperty(r,o,a),a};Object.defineProperty(r,"__esModule",{value:!0}),r.PortForwardingService=void 0;const n=o(81644),a=o(76994),i=o(65357),d=o(39144),c=o(98744),l=o(99949),w=o(97683),h=o(601),p=o(92691),u=o(1449),F=o(94421),f=o(88682),P=o(48381),m=o(65284);let y=t=class extends n.SshService{constructor(e){super(e),this.localForwarders=new Map,this.remoteConnectors=new Map,this.streamForwarders=[],this.acceptLocalConnectionsForForwardedPorts=!0,this.forwardConnectionsToLocalPorts=!0,this.acceptRemoteConnectionsForNonForwardedPorts=!0,this.localForwardedPorts=new d.ForwardedPortsCollection,this.remoteForwardedPorts=new d.ForwardedPortsCollection,this.tcpListenerFactory=new p.DefaultTcpListenerFactory,this.messageFactory=new u.DefaultPortForwardMessageFactory,this.forwardedPortConnectingEmitter=new a.Emitter,this.onForwardedPortConnecting=this.forwardedPortConnectingEmitter.event}async forwardedPortConnecting(e,r,o,t){try{const s=new m.ForwardedPortConnectingEventArgs(e,r,o,t);if(this.forwardedPortConnectingEmitter.fire(s),s.transformPromise)return await s.transformPromise}catch(e){if(!(e instanceof Error))throw e;return this.trace(n.TraceLevel.Warning,n.SshTraceEventIds.portForwardConnectionFailed,`Forwarded port connecting event-handler failed: ${e.message}`),null}return o}async forwardFromRemotePort(e,r,o,t,s){const n="string"==typeof o?o:"127.0.0.1";if(void 0===t&&(t=r),!e)throw new TypeError("Remote IP address is required.");if(!Number.isInteger(r)||r<0)throw new TypeError("Remote port must be a non-negative integer.");if(!n)throw new TypeError("Local host is required.");if(!Number.isInteger(t)||t<=0)throw new TypeError("Local port must be a positive integer.");if(this.localForwardedPorts.find((e=>e.localPort===t)))throw new Error(`Local port ${t} is already forwarded.`);if(r>0&&this.localForwardedPorts.find((e=>e.remotePort===r)))throw new Error(`Remote port ${r} is already forwarded.`);const a=new f.RemotePortForwarder(this,this.session,e,r,n,t),d=await this.messageFactory.createRequestMessageAsync(r);if(!await a.request(d,s))return null;if(r=a.remotePort,this.remoteConnectors.has(r))return null;this.remoteConnectors.set(r,a);const c=new i.ForwardedPort(t,r,!1);return this.localForwardedPorts.addOrUpdatePort(c),a.onDisposed((()=>{this.localForwardedPorts.removePort(c),this.remoteConnectors.delete(r)})),a}async forwardToRemotePort(e,r,o,s,n){const a="string"==typeof o?o:"127.0.0.1";if(void 0===s&&(s=r),!e)throw new TypeError("Local IP address is required.");if(!Number.isInteger(r)||r<0)throw new TypeError("Local port must be a non-negative integer.");if(!a)throw new TypeError("Remote host is required.");if(!Number.isInteger(s)||s<=0)throw new TypeError("Remote port must be a positive integer.");if(this.localForwarders.has(s))throw new Error(`Port ${s} is already forwarded.`);const i=new F.LocalPortForwarder(this,this.session,t.reversePortForwardChannelType,e,r,a,s);return await i.startForwarding(n),this.localForwarders.set(s,i),i.onDisposed((()=>{this.localForwarders.delete(s)})),i}async streamFromRemotePort(e,r,o){if(!e)throw new TypeError("Remote IP address is required.");if(!Number.isInteger(r)||r<0)throw new TypeError("Remote port must be a non-negative integer.");const t=new P.RemotePortStreamer(this.session,e,r),s=await this.messageFactory.createRequestMessageAsync(r);if(!await t.request(s,o))return t.dispose(),null;r=t.remotePort,this.remoteConnectors.set(r,t);const n=new i.ForwardedPort(null,r,!1);return this.localForwardedPorts.addOrUpdatePort(n),t.onDisposed((()=>{this.localForwardedPorts.removePort(n),this.remoteConnectors.delete(r)})),t}async streamToRemotePort(e,r,o){if(!e)throw new TypeError("Remote host is required.");if(!Number.isInteger(r)||r<=0)throw new TypeError("Remote port must be a positive integer.");const s=await this.openChannel(this.session,t.reversePortForwardChannelType,null,null,e,r,o);return new n.SshStream(s)}async connectToForwardedPort(e,r){if(!Number.isInteger(e)||e<=0)throw new TypeError("Forwarded port must be a positive integer.");const o=await this.openChannel(this.session,t.portForwardChannelType,null,null,"127.0.0.1",e,r),s=await this.forwardedPortConnecting(e,!1,new n.SshStream(o),r);if(!s)throw o.close().catch((e=>{})),new n.SshChannelError("The connection to the forwarded port was rejected by the connecting event-handler.");return s}async waitForForwardedPort(e,r){if(this.remoteForwardedPorts.find((r=>r.remotePort===e)))return;const o=new n.PromiseCompletionSource;let t,s,a;r&&(t=r.onCancellationRequested((()=>o.reject(new n.CancellationError))));try{s=this.remoteForwardedPorts.onPortAdded((r=>{r.port.remotePort===e&&o.resolve()})),a=this.session.onClosed((()=>{o.reject(new n.ObjectDisposedError("The session was closed."))})),await o.promise}finally{null==s||s.dispose(),null==a||a.dispose(),null==t||t.dispose()}}async onSessionRequest(e,r){if(!e)throw new TypeError("Request is required.");if(e.requestType!==t.portForwardRequestType&&e.requestType!==t.cancelPortForwardRequestType)throw new Error(`Unexpected request type: ${e.requestType}`);const o=e.request.convertTo(new w.PortForwardRequestMessage),s=c.IPAddressConversions.fromSshAddress(o.addressToBind);if(e.requestType===t.portForwardRequestType&&0!==o.port&&this.localForwarders.has(o.port)){const r=`PortForwardingService port ${o.port} is already forwarded.`;return this.session.trace(n.TraceLevel.Verbose,n.SshTraceEventIds.portForwardRequestInvalid,r),void(e.isAuthorized=!1)}const a=new n.SshRequestEventArgs(e.requestType,o,this.session.principal);let d;await super.onSessionRequest(a,r);let l=null;if(a.isAuthorized)if(e.requestType===t.portForwardRequestType){try{l=await this.startForwarding(s,o.port,r)}catch(e){}if(null!==l){const e=0===o.port?l:o.port,r=await this.messageFactory.createSuccessMessageAsync(e);r.port=e,d=r}}else e.requestType===t.cancelPortForwardRequestType&&await this.cancelForwarding(o.port,r)&&(d=new n.SessionRequestSuccessMessage);if(e.responsePromise=Promise.resolve(null!=d?d:new n.SessionRequestFailureMessage),d instanceof h.PortForwardSuccessMessage){const e=new i.ForwardedPort(null!=l?l:d.port,d.port,!0);this.remoteForwardedPorts.addOrUpdatePort(e)}}async startForwarding(e,r,o){if("number"!=typeof r)throw new TypeError("Remote port must be an integer.");if(this.acceptLocalConnectionsForForwardedPorts){let s=r;const n=new F.LocalPortForwarder(this,this.session,t.portForwardChannelType,e,s,void 0,0===r?void 0:r);return await n.startForwarding(o),s=n.localPort,0===r&&(r=s),this.localForwarders.has(r)?(n.dispose(),null):(this.localForwarders.set(r,n),s=n.localPort,n.onDisposed((()=>{const e=new i.ForwardedPort(s,r,!0);this.remoteForwardedPorts.removePort(e),this.localForwarders.delete(r)})),s)}return 0!==r?r:null}async cancelForwarding(e,r){const o=this.localForwarders.get(e);if(o)return this.localForwarders.delete(e),o.dispose(),!0;const t=new i.ForwardedPort(e,e,!0);return!!this.remoteForwardedPorts.removePort(t)}async onChannelOpening(e,r){var o;if(!e)throw new TypeError("Request is required.");const s=e.request.channelType;if(s!==t.portForwardChannelType&&s!==t.reversePortForwardChannelType)return void(e.failureReason=n.SshChannelOpenFailureReason.unknownChannelType);let a=null;const d=e.request instanceof l.PortForwardChannelOpenMessage?e.request:e.request.convertTo(new l.PortForwardChannelOpenMessage);if(e.isRemoteRequest)if(s===t.portForwardChannelType){const r=`${c.IPAddressConversions.fromSshAddress(d.host)}:${d.port}`;if(a=null!==(o=this.remoteConnectors.get(d.port))&&void 0!==o?o:null,!a)return this.trace(n.TraceLevel.Error,n.SshTraceEventIds.portForwardRequestInvalid,`PortForwardingService received forwarding channel for ${r} that was not requested.`),e.failureReason=n.SshChannelOpenFailureReason.connectFailed,void(e.failureDescription="Forwarding channel was not requested.")}else if(!this.acceptRemoteConnectionsForNonForwardedPorts){const r="The session has disabled connections to non-forwarded ports.";return this.session.trace(n.TraceLevel.Warning,n.SshTraceEventIds.portForwardChannelOpenFailed,r),e.failureReason=n.SshChannelOpenFailureReason.administrativelyProhibited,void(e.failureDescription=r)}const w=new n.SshChannelOpeningEventArgs(d,e.channel,e.isRemoteRequest);if(await super.onChannelOpening(w,r),e.failureReason=w.failureReason,e.failureDescription=w.failureDescription,e.openingPromise=w.openingPromise,e.failureReason===n.SshChannelOpenFailureReason.none&&e.isRemoteRequest&&this.forwardConnectionsToLocalPorts)if(a){await a.onPortChannelOpening(e,r);const o=a instanceof f.RemotePortForwarder?a.localPort:null,t=a instanceof f.RemotePortForwarder?a.remotePort:d.port,s=new i.ForwardedPort(o,t,!1);this.localForwardedPorts.addChannel(s,e.channel)}else await f.RemotePortForwarder.forwardChannel(this,e,d.host,d.port,d.port,this.trace,r),e.failureReason!==n.SshChannelOpenFailureReason.none&&await e.channel.close(r)}async openChannel(e,r,o,s,a,i,d){let c;if(r===t.portForwardChannelType&&(c=this.remoteForwardedPorts.find((e=>e.remotePort===i||null===e.remotePort&&e.localPort===i)),!c))throw new Error(`Port ${i} is not being forwarded.`);const l=await this.messageFactory.createChannelOpenMessageAsync(i);l.channelType=r,l.originatorIPAddress=null!=o?o:"",l.originatorPort=null!=s?s:0,l.host=a,l.port=i;const w=this.session.trace;let h;try{h=await e.openChannel(l,null,d),w(n.TraceLevel.Info,n.SshTraceEventIds.portForwardChannelOpened,`PortForwardingService opened ${r} channel #${h.channelId} for ${a}:${i}.`)}catch(e){if(!(e instanceof Error))throw e;throw w(n.TraceLevel.Error,n.SshTraceEventIds.portForwardChannelOpenFailed,`PortForwardingService failed to open ${r} channel for ${a}:${i}: ${e.message}`,e),e}return r===t.portForwardChannelType&&this.remoteForwardedPorts.addChannel(c,h),h}dispose(){const e=[...this.localForwarders.values(),...this.remoteConnectors.values()];this.streamForwarders.splice(0,this.streamForwarders.length),this.localForwarders.clear(),this.remoteConnectors.clear();for(const r of e)r.dispose();super.dispose()}};y.portForwardRequestType="tcpip-forward",y.cancelPortForwardRequestType="cancel-tcpip-forward",y.portForwardChannelType="forwarded-tcpip",y.reversePortForwardChannelType="direct-tcpip",y=t=s([(0,n.serviceActivation)({sessionRequest:t.portForwardRequestType}),(0,n.serviceActivation)({sessionRequest:t.cancelPortForwardRequestType}),(0,n.serviceActivation)({channelType:t.portForwardChannelType}),(0,n.serviceActivation)({channelType:t.reversePortForwardChannelType})],y),r.PortForwardingService=y}}]);