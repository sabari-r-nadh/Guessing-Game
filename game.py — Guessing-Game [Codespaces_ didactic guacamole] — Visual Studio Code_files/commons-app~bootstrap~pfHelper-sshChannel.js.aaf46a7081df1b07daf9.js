"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[198],{92115:(e,s,t)=>{var i=t(38891).Buffer;Object.defineProperty(s,"__esModule",{value:!0}),s.SshChannel=void 0;const n=t(76994),o=t(38762),a=t(99293),h=t(80260),r=t(55016),l=t(90427),d=t(22653),c=t(57744),w=t(18406),m=t(97750),C=t(12431),u=t(98149),S=t(25528),p=t(65250);class f{constructor(e,s,t,i,o,a,h,l){this.connectionService=e,this.channelType=s,this.channelId=t,this.remoteChannelId=i,this.openMessage=h,this.openConfirmationMessage=l,this.remoteClosed=!1,this.localClosed=!1,this.sentEof=!1,this.disposed=!1,this.openSendingWindowCompletionSource=null,this.requestCompletionSources=new p.Queue,this.sendSemaphore=new C.Semaphore(0),this.metrics=new r.ChannelMetrics,this.dataReceivedEmitter=new n.Emitter,this.extendedDataReceivedEmitter=new n.Emitter,this.onDataReceived=this.dataReceivedEmitter.event,this.onExtendedDataReceived=this.extendedDataReceivedEmitter.event,this.eofEmitter=new n.Emitter,this.onEof=this.eofEmitter.event,this.closedEmitter=new n.Emitter,this.onClosed=this.closedEmitter.event,this.requestEmitter=new n.Emitter,this.onRequest=this.requestEmitter.event,this.isMaxWindowSizeLocked=!1,this.remoteWindowSize=o,this.maxWindowSizeValue=f.defaultMaxWindowSize,this.windowSize=this.maxWindowSizeValue,this.maxPacketSize=Math.min(a,f.defaultMaxPacketSize)}get session(){return this.connectionService.session}get isClosed(){return this.localClosed||this.remoteClosed}get maxWindowSize(){return this.maxWindowSizeValue}set maxWindowSize(e){if(this.isMaxWindowSizeLocked)throw new Error("Cannot change the max window size after opening the channel.");if(e<this.maxPacketSize)throw new Error("Maximum window size cannot be less than maximum packet size.");this.maxWindowSizeValue=e}async request(e,s){if(!e)throw new TypeError("Request is required.");if(this.disposed)throw new d.ObjectDisposedError(this);if(e.recipientChannel=this.remoteChannelId,!e.wantReply)return await this.session.sendMessage(e,s),!0;const t=new l.PromiseCompletionSource;if(s){if(s.isCancellationRequested)throw new m.CancellationError;s.onCancellationRequested((()=>{t.reject(new m.CancellationError)}))}return this.requestCompletionSources.enqueue(t),await this.session.sendMessage(e,s),await t.promise}async send(e,s){return this.sendCommon(e,void 0,s)}async sendExtendedData(e,s,t){return this.sendCommon(s,e,t)}async sendCommon(e,s,t){if(this.disposed)throw new d.ObjectDisposedError(this);if(0!==e.length){if(this.sentEof)throw new Error("Cannot send more data after EOF.");await this.sendSemaphore.wait(t);try{let n=0,o=e.length;for(;o>0;){let h,r=Math.min(Math.min(this.remoteWindowSize,this.maxPacketSize),o);for(;0===r;)this.openSendingWindowCompletionSource||(this.openSendingWindowCompletionSource=new l.PromiseCompletionSource),this.session.trace(u.TraceLevel.Warning,u.SshTraceEventIds.channelWaitForWindowAdjust,`${this} send window is full. Waiting for window adjustment before sending.`),await(0,m.withCancellation)(this.openSendingWindowCompletionSource.promise,t),this.openSendingWindowCompletionSource=null,r=Math.min(Math.min(this.remoteWindowSize,this.maxPacketSize),o);void 0!==s?(h=new a.ChannelExtendedDataMessage,h.dataTypeCode=s):h=new a.ChannelDataMessage,h.recipientChannel=this.remoteChannelId,h.data=i.from(e.slice(n,n+r)),await this.session.sendMessage(h,t),this.remoteWindowSize-=r,o-=r,n+=r,this.metrics.addBytesSent(r)}}finally{this.sendSemaphore.tryRelease()}}else await this.sendEof()}enableSending(){this.sendSemaphore.tryRelease()}async sendEof(e){if(!this.sentEof){await this.sendSemaphore.wait(e);try{this.sentEof=!0;const s=new a.ChannelEofMessage;s.recipientChannel=this.remoteChannelId,await this.session.sendMessage(s,e)}finally{this.sendSemaphore.tryRelease()}}}async handleRequest(e,s){if(!e.requestType)throw new d.SshConnectionError("Channel request type not specified.",h.SshDisconnectReason.protocolError);if(e.requestType===a.ChannelRequestType.exitStatus){const s=new a.ChannelSignalMessage;return e.convertTo(s),this.exitStatus=s.exitStatus,!0}if(e.requestType===a.ChannelRequestType.exitSignal){const s=new a.ChannelSignalMessage;return e.convertTo(s),this.exitSignal=s.exitSignal,this.exitErrorMessage=s.errorMessage,!0}if(e.requestType===a.ChannelRequestType.signal){const s=new a.ChannelSignalMessage;e.convertTo(s)}const t=new c.SshRequestEventArgs(e.requestType,e,this.session.principal,s),i=(0,o.findService)(this.session.config.services,(s=>(!s.channelType||s.channelType===this.channelType)&&s.channelRequest===e.requestType));await this.sendSemaphore.wait(s);try{let n=null;if(i){const e=this.session.activateService(i);await e.onChannelRequest(this,t,s)}else this.requestEmitter.fire(t);t.responsePromise&&(n=await t.responsePromise,t.isAuthorized=n instanceof a.ChannelSuccessMessage),e.wantReply&&(t.isAuthorized?(n=null!=n?n:new a.ChannelSuccessMessage,n.recipientChannel=this.remoteChannelId):(n=null!=n?n:new a.ChannelFailureMessage,n.recipientChannel=this.remoteChannelId),await this.session.sendMessage(n,s))}finally{this.sendSemaphore.tryRelease()}return t.isAuthorized||!1}handleResponse(e){const s=this.requestCompletionSources.dequeue();s&&s.resolve(e)}handleDataReceived(e){this.metrics.addBytesReceived(e.length),this.dataReceivedEmitter.fire(e)}handleExtendedDataReceived(e){this.metrics.addBytesReceived(e.data.length),this.extendedDataReceivedEmitter.fire(e)}adjustWindow(e){if(!this.disposed&&(this.windowSize-=e,this.windowSize<=this.maxWindowSizeValue/2)){const e=new a.ChannelWindowAdjustMessage;e.recipientChannel=this.remoteChannelId,e.bytesToAdd=this.maxWindowSizeValue-this.windowSize,this.windowSize=this.maxWindowSizeValue,this.session.sendMessage(e).catch((e=>{this.session.trace(u.TraceLevel.Error,u.SshTraceEventIds.channelWindowAdjustFailed,`Error sending window adjust message: ${e.message}`,e)}))}}adjustRemoteWindow(e){this.remoteWindowSize+=e,this.openSendingWindowCompletionSource&&this.openSendingWindowCompletionSource.resolve(void 0)}handleEof(){this.session.trace(u.TraceLevel.Info,u.SshTraceEventIds.channelEofReceived,`${this} EOF received.`),this.eofEmitter.fire()}close(e,s,t){if(e instanceof Error){const s=e;return this.localClosed||(this.localClosed=!0,this.session.trace(u.TraceLevel.Info,u.SshTraceEventIds.channelClosed,`${this} Closed: ${s.message}`),this.closedEmitter.fire(new w.SshChannelClosedEventArgs(s))),void this.disposeInternal()}return"number"==typeof e?this.closeWithStatus(e,s):"string"==typeof e?this.closeWithSignal(e,s,t):this.closeDefault(e)}async closeDefault(e){if(!this.remoteClosed&&!this.localClosed){this.remoteClosed=!0,await this.sendSemaphore.wait(e);try{const e=new a.ChannelCloseMessage;e.recipientChannel=this.remoteChannelId,await this.session.sendMessage(e)}catch(e){}finally{this.sendSemaphore.tryRelease()}}if(!this.localClosed){this.localClosed=!0;this.raiseClosedEvent()}this.disposeInternal()}async closeWithStatus(e,s){if(!this.remoteClosed&&!this.localClosed){this.exitStatus=e;const s=new a.ChannelSignalMessage;s.recipientChannel=this.remoteChannelId,s.exitStatus=e,await this.session.sendMessage(s)}await this.closeDefault(s)}async closeWithSignal(e,s,t){if(!this.remoteClosed&&!this.localClosed){this.exitSignal=e,this.exitErrorMessage=s;const t=new a.ChannelSignalMessage;t.recipientChannel=this.remoteChannelId,t.exitSignal=e,t.errorMessage=s,await this.session.sendMessage(t)}await this.closeDefault(t)}handleClose(){if(!this.localClosed){this.localClosed=!0;this.raiseClosedEvent(!0)}this.disposeInternal()}raiseClosedEvent(e=!1){const s=` (S: ${this.metrics.bytesSent}, R: ${this.metrics.bytesReceived})`,t=e?"remotely":"locally";let i,n;return void 0!==this.exitStatus?(n=new w.SshChannelClosedEventArgs(this.exitStatus),i=`${this} closed ${t}: status=${this.exitStatus}`):void 0!==this.exitSignal?(n=new w.SshChannelClosedEventArgs(this.exitSignal,this.exitErrorMessage),i=`${this} closed ${t}: signal=${this.exitSignal} ${this.exitErrorMessage}`):(n=new w.SshChannelClosedEventArgs,i=`${this} closed ${t}.`),this.session.trace(u.TraceLevel.Info,u.SshTraceEventIds.channelClosed,i+s),this.closedEmitter.fire(n),i}dispose(){if(!this.disposed&&!this.localClosed){if(!this.remoteClosed){this.remoteClosed=!0;const e=new a.ChannelCloseMessage;e.recipientChannel=this.remoteChannelId,this.session.sendMessage(e).catch((e=>{}))}const e=this.session.isClosed?`${this.session} closed.`:`${this} disposed.`;this.session.trace(u.TraceLevel.Info,u.SshTraceEventIds.channelClosed,e);const s=new w.SshChannelClosedEventArgs("SIGABRT",e);this.localClosed=!0,this.closedEmitter.fire(s)}this.disposeInternal()}disposeInternal(){this.disposed||(this.disposed=!0,this.cancelPendingRequests(),this.connectionService.removeChannel(this),this.sendSemaphore.dispose())}pipe(e){return S.PipeExtensions.pipeChannel(this,e)}cancelPendingRequests(){for(const e of this.requestCompletionSources)e.resolve(!1)}toString(){return`SshChannel(Type: ${this.channelType}, Id: ${this.channelId}, RemoteId: ${this.remoteChannelId})`}}s.SshChannel=f,f.sessionChannelType="session",f.defaultMaxPacketSize=a.ChannelOpenMessage.defaultMaxPacketSize,f.defaultMaxWindowSize=a.ChannelOpenMessage.defaultMaxWindowSize}}]);