"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[501],{48577:(e,n,s)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.TunnelConnectionSession=void 0;const t=s(5037),o=s(74061),i=s(81644),c=s(76994),r=s(76553),a=s(10269),h=s(31338),l=s(27364),u=s(67322),T=s(8068),d=s(99248),g=s(32887),S=s(69441);class R extends l.TunnelConnectionBase{get connectionProtocol(){return this.connectionProtocolValue}set connectionProtocol(e){this.connectionProtocolValue=e}get isClientConnection(){return this.tunnelAccessScope===t.TunnelAccessScopes.Connect}get connectionRole(){return this.isClientConnection?"client":"host"}constructor(e,n,s,t){super(e),this.connectionProtocols=n,this.managementClient=t,this.connectedTunnel=null,this.refreshingTunnelEmitter=new h.TrackingEmitter,this.reportProgressEmitter=new c.Emitter,this.onReportProgress=this.reportProgressEmitter.event,this.streamFactory=new S.DefaultTunnelRelayStreamFactory,this.sshSessionDisposables=[],this.refreshingTunnel=this.refreshingTunnelEmitter.event,this.enableE2EEncryption=!0,this.trace=null!=s?s:()=>{},this.httpAgent=null==t?void 0:t.httpsAgent}raiseReportProgress(e,n){const s={progress:e,sessionNumber:n};this.reportProgressEmitter.fire(s)}get tunnel(){return this.connectedTunnel}set tunnel(e){e!==this.connectedTunnel&&(this.connectedTunnel=e,this.tunnelChanged())}tunnelChanged(){this.tunnel?this.accessToken=o.TunnelAccessTokenProperties.getTunnelAccessToken(this.tunnel,this.tunnelAccessScope):this.accessToken=void 0}get isReconnectable(){return!!this.connector}get disconnectReason(){return this.disconnectionReason}set disconnectReason(e){this.disconnectionReason=e}async createSessionStream(e,n){if(!this.relayUri)throw new Error("Cannot create tunnel session stream. Tunnel relay endpoint URI is missing");if(this.isClientConnection?this.raiseReportProgress(i.Progress.OpeningClientConnectionToRelay):this.raiseReportProgress(i.Progress.OpeningHostConnectionToRelay),this.trace(i.TraceLevel.Info,0,`Connecting to ${this.connectionRole} tunnel relay ${this.relayUri}`),this.trace(i.TraceLevel.Verbose,0,`Sec-WebSocket-Protocol: ${this.connectionProtocols.join(", ")}`),this.accessToken){const e=o.TunnelAccessTokenProperties.getTokenTrace(this.accessToken);this.trace(i.TraceLevel.Verbose,0,`Authorization: tunnel <${e}>`)}const s={tlsOptions:{agent:this.httpAgent}},t=await this.streamFactory.createRelayStream(this.relayUri,this.connectionProtocols,this.accessToken,s);return this.trace(i.TraceLevel.Verbose,0,`Connected with subprotocol '${t.protocol}'`),this.isClientConnection?this.raiseReportProgress(i.Progress.OpenedClientConnectionToRelay):this.raiseReportProgress(i.Progress.OpenedHostConnectionToRelay),t}configureSession(e,n,s,t){throw new Error("Not implemented")}async closeSession(e,n){this.unsubscribeSessionEvents();const s=this.sshSession;s&&(s.isClosed?this.sshSession=void 0:await s.close(e||i.SshDisconnectReason.none,void 0,n),s.dispose())}async dispose(){this.disconnectReason!==i.SshDisconnectReason.none&&void 0!==this.disconnectReason||(this.disconnectReason=i.SshDisconnectReason.byApplication),await super.dispose();try{await this.closeSession(this.disconnectReason,this.disconnectError)}catch(e){if(!(e instanceof i.ObjectDisposedError))throw e}}async refreshTunnelAccessToken(e){var n;if(this.isDisposed)return!1;if(!this.isRefreshingTunnelAccessTokenEventHandled&&!this.canRefreshTunnel)return!1;this.connectionStatus=r.ConnectionStatus.RefreshingTunnelAccessToken;try{return this.traceVerbose(`Refreshing tunnel access token. Current token: ${o.TunnelAccessTokenProperties.getTokenTrace(this.accessToken)}`),this.isRefreshingTunnelAccessTokenEventHandled?this.accessToken=null!==(n=await this.getFreshTunnelAccessToken(e))&&void 0!==n?n:void 0:await this.refreshTunnel(!1,e),this.traceVerbose(`Refreshed tunnel access token. New token: ${o.TunnelAccessTokenProperties.getTokenTrace(this.accessToken)}`),!0}finally{this.connectionStatus=r.ConnectionStatus.Connecting}}startConnecting(){this.connectionStatus=r.ConnectionStatus.Connecting}finishConnecting(e,n){void 0===e||e===i.SshDisconnectReason.none?(this.connectionStatus===r.ConnectionStatus.Connecting&&(this.disconnectError=void 0,this.disconnectReason=void 0),this.connectionStatus=r.ConnectionStatus.Connected):this.connectionStatus!==r.ConnectionStatus.Disconnected&&(this.disconnectReason=e,n&&(this.disconnectError=n),this.connectionStatus=r.ConnectionStatus.Disconnected)}get canRefreshTunnel(){return this.tunnel&&this.managementClient||this.refreshingTunnelEmitter.isSubscribed}async refreshTunnel(e,n){this.traceInfo("Refreshing tunnel.");let s=!1;const t=new g.RefreshingTunnelEventArgs(this.tunnelAccessScope,this.tunnel,!!e,this.managementClient,n);if(this.refreshingTunnelEmitter.fire(t),t.tunnelPromise&&(this.tunnel=await t.tunnelPromise,s=!0),!s&&this.tunnel&&this.managementClient){const t={tokenScopes:[this.tunnelAccessScope],includePorts:e};this.tunnel=await(0,h.withCancellation)(this.managementClient.getTunnel(this.tunnel,t),n),s=!0}return s&&(this.tunnel?this.traceInfo("Refreshed tunnel."):this.traceInfo("Tunnel not found.")),!0}createTunnelConnector(){return new a.RelayTunnelConnector(this)}traceInfo(e){this.trace(i.TraceLevel.Info,0,e)}traceVerbose(e){this.trace(i.TraceLevel.Verbose,0,e)}traceWarning(e,n){this.trace(i.TraceLevel.Warning,0,e,n)}traceError(e,n){this.trace(i.TraceLevel.Error,0,e,n)}onSshSessionClosed(e){this.unsubscribeSessionEvents(),this.sshSession=void 0,this.maybeStartReconnecting(e.reason,e.message,e.error)}maybeStartReconnecting(e,n,s){var t,o;const c=`Connection to ${this.connectionRole} tunnel relay closed.${this.getDisconnectReason(e,n,s)}`;this.isDisposed||this.connectionStatus===r.ConnectionStatus.Disconnected?this.traceInfo(c):(s&&(this.disconnectError=s,this.disconnectReason=e),this.connectionStatus!==r.ConnectionStatus.Connected||this.reconnectPromise?this.traceInfo(c):(null===(o=null===(t=this.connectionOptions)||void 0===t?void 0:t.enableReconnect)||void 0===o||o)&&e===i.SshDisconnectReason.connectionLost&&this.connector?(this.traceInfo(`${c} Reconnecting.`),this.reconnectPromise=(async()=>{try{await this.connectTunnelSession()}catch(e){}this.reconnectPromise=void 0})()):(this.traceInfo(c),this.connectionStatus=r.ConnectionStatus.Disconnected))}getDisconnectReason(e,n,s){switch(e){case i.SshDisconnectReason.connectionLost:return` ${n||(null==s?void 0:s.message)||"Connection lost."}`;case i.SshDisconnectReason.authCancelledByUser:case i.SshDisconnectReason.noMoreAuthMethodsAvailable:case i.SshDisconnectReason.hostNotAllowedToConnect:case i.SshDisconnectReason.illegalUserName:return" Not authorized.";case i.SshDisconnectReason.serviceNotAvailable:return" Service not available.";case i.SshDisconnectReason.compressionError:case i.SshDisconnectReason.keyExchangeFailed:case i.SshDisconnectReason.macError:case i.SshDisconnectReason.protocolError:return" Protocol error.";case i.SshDisconnectReason.tooManyConnections:return this.isClientConnection?" Too many client connections.":" Another host for the tunnel has connected.";default:return""}}async connectSession(e){try{await e()}catch(e){if(!(e instanceof i.CancellationError))if(e instanceof Error)this.traceError(`Error connecting ${this.connectionRole} tunnel session: ${e.message}`,e);else{const n=`Error connecting ${this.connectionRole} tunnel session: ${e}`;this.traceError(n)}throw e}}async connectTunnelSession(e,n,s){var t;e&&(this.tunnel=e),n&&(this.connectionOptions=n,null!==(t=this.httpAgent)&&void 0!==t||(this.httpAgent=null==n?void 0:n.httpAgent)),await this.connectSession((async()=>{const t=this.isReconnectable&&!e;await this.onConnectingToTunnel(),this.connector||(this.connector=this.createTunnelConnector());const o=[];if(s){const e=new c.CancellationTokenSource;o.push(e,s.onCancellationRequested((()=>e.cancel())),this.disposeToken.onCancellationRequested((()=>e.cancel()))),s=e.token}else s=this.disposeToken;try{await this.connector.connectSession(t,n,s)}catch(e){throw e instanceof i.CancellationError&&this.throwIfDisposed(`CancelationError: ${e.message}`,e.stack),e}finally{for(const e of o)e.dispose()}}))}onConnectingToTunnel(){return Promise.resolve()}validateAccessToken(){if(this.accessToken)return o.TunnelAccessTokenProperties.validateTokenExpiration(this.accessToken),this.accessToken}createRequestMessageAsync(e){const n=new T.PortRelayRequestMessage;return n.accessToken=this.accessToken,Promise.resolve(n)}createSuccessMessageAsync(e){const n=new u.PortForwardSuccessMessage;return Promise.resolve(n)}createChannelOpenMessageAsync(e){const n=new d.PortRelayConnectRequestMessage;return n.accessToken=this.accessToken,n.isE2EEncryptionRequested=this.enableE2EEncryption,Promise.resolve(n)}unsubscribeSessionEvents(){this.sshSessionDisposables.forEach((e=>e.dispose())),this.sshSessionDisposables=[]}}n.TunnelConnectionSession=R}}]);