"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[909],{86259:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TunnelManagementHttpClient=t.ManagementApiVersions=void 0;const s=n(5037),r=n(96435),o=n(26905),i=n(50981),a=n(83139),l=n(94494),u=n(63010),c=n(76994),d="/tunnels",p="/endpoints",h="/ports",T="Authorization";function v(e,t){var n,s;return(null!==(n=e.portNumber)&&void 0!==n?n:Number.MAX_SAFE_INTEGER)-(null!==(s=t.portNumber)&&void 0!==s?s:Number.MAX_SAFE_INTEGER)}function g(e){return"string"==typeof e?new Date(Date.parse(e)):e}function f(e){e&&(e.created=g(e.created),e.status&&(e.status.lastHostConnectionTime=g(e.status.lastHostConnectionTime),e.status.lastClientConnectionTime=g(e.status.lastClientConnectionTime)))}function m(e){e&&e.status&&(e.status.lastClientConnectionTime=g(e.status.lastClientConnectionTime))}function w(e,t){var n;if(e.accessTokens&&t){null!==(n=t.accessTokens)&&void 0!==n||(t.accessTokens={});for(const n of Object.entries(e.accessTokens))t.accessTokens[n[0]]||(t.accessTokens[n[0]]=n[1])}}!function(e){e.Version20230927preview="2023-09-27-preview"}(t.ManagementApiVersions||(t.ManagementApiVersions={}));const b=[s.TunnelAccessScopes.Manage],R=[s.TunnelAccessScopes.Host],y=[s.TunnelAccessScopes.Manage,s.TunnelAccessScopes.ManagePorts,s.TunnelAccessScopes.Host],$=[s.TunnelAccessScopes.Manage,s.TunnelAccessScopes.ManagePorts,s.TunnelAccessScopes.Host,s.TunnelAccessScopes.Connect],P=["2023-09-27-preview"];class E{constructor(e,t,n,r,o,i){var a;if(this.httpsAgent=o,this.adapter=i,this.reportProgressEmitter=new c.Emitter,this.onReportProgress=this.reportProgressEmitter.event,this.trace=e=>{},-1===P.indexOf(t))throw new TypeError(`Invalid API version: ${t}, must be one of ${P}`);if(this.apiVersion=t,!e)throw new TypeError("User agent must be provided.");if(Array.isArray(e)){if(0===e.length)throw new TypeError("User agents cannot be empty.");let t="";e.forEach((e=>{var n;if("string"!=typeof e){if(!e.name)throw new TypeError("Invalid user agent. The name must be provided.");if("string"!=typeof e.name)throw new TypeError("Invalid user agent. The name must be a string.");if(e.version&&"string"!=typeof e.version)throw new TypeError("Invalid user agent. The version must be a string.");t=`${t}${e.name}/${null!==(n=e.version)&&void 0!==n?n:"unknown"} `}else t=`${t}${e} `})),this.userAgents=t.trim()}else if("string"!=typeof e){if(!e.name)throw new TypeError("Invalid user agent. The name must be provided.");if("string"!=typeof e.name)throw new TypeError("Invalid user agent. The name must be a string.");if(e.version&&"string"!=typeof e.version)throw new TypeError("Invalid user agent. The version must be a string.");this.userAgents=`${e.name}/${null!==(a=e.version)&&void 0!==a?a:"unknown"}`}else this.userAgents=e;this.userTokenCallback=null!=n?n:()=>Promise.resolve(null),r||(r=s.TunnelServiceProperties.production.serviceUri);const l=new URL(r);if(!l||"/"!==l.pathname)throw new TypeError(`Invalid tunnel service URI: ${r}`);this.baseAddress=r}async listTunnels(e,t,n,s){const r=[e?null:"global=true",t?`domain=${t}`:null].filter((e=>!!e)).join("&"),o=await this.sendRequest("GET",e,d,r,n,void 0,void 0,s);let i=new Array;if(o.value)for(const e of o.value)e.value&&(i=i.concat(e.value));return i.forEach(f),i}async getTunnel(e,t,n){const s=await this.sendTunnelRequest("GET",e,$,void 0,void 0,t,void 0,void 0,n);return w(e,s),f(s),s}async createTunnel(e,t,n){const s=e.tunnelId,r=null==s||""===s;(t=t||{}).additionalHeaders=t.additionalHeaders||{},t.additionalHeaders["If-Not-Match"]="*",r&&(e.tunnelId=u.IdGeneration.generateTunnelId());for(let s=0;s<=3;s++)try{const s=await this.sendTunnelRequest("PUT",e,b,void 0,void 0,t,this.convertTunnelForRequest(e),void 0,n,!0);return w(e,s),f(s),s}catch(t){if(!r)throw t;e.tunnelId=u.IdGeneration.generateTunnelId()}const o=await this.sendTunnelRequest("PUT",e,b,void 0,void 0,t,this.convertTunnelForRequest(e),void 0,n,!0);return w(e,o),f(o),o}async createOrUpdateTunnel(e,t,n){const s=e.tunnelId,r=null==s||""===s;r&&(e.tunnelId=u.IdGeneration.generateTunnelId());for(let s=0;s<=3;s++)try{const s=await this.sendTunnelRequest("PUT",e,b,void 0,void 0,t,this.convertTunnelForRequest(e),void 0,n,!0);return w(e,s),f(s),s}catch(t){if(!r)throw t;e.tunnelId=u.IdGeneration.generateTunnelId()}const o=await this.sendTunnelRequest("PUT",e,b,void 0,"forceCreate=true",t,this.convertTunnelForRequest(e),void 0,n,!0);return w(e,o),f(o),o}async updateTunnel(e,t,n){(t=t||{}).additionalHeaders=t.additionalHeaders||{},t.additionalHeaders["If-Match"]="*";const s=await this.sendTunnelRequest("PUT",e,b,void 0,void 0,t,this.convertTunnelForRequest(e),void 0,n);return w(e,s),f(s),s}async deleteTunnel(e,t,n){return await this.sendTunnelRequest("DELETE",e,b,void 0,void 0,t,void 0,!0,n)}async updateTunnelEndpoint(e,t,n,s){if(null==t.id)throw new Error("Endpoint ID must be specified when updating an endpoint.");const r=`${p}/${t.id}`,o=await this.sendTunnelRequest("PUT",e,R,r,"connectionMode="+t.connectionMode,n,t,void 0,s);return e.endpoints&&(e.endpoints=e.endpoints.filter((e=>e.hostId!==t.hostId||e.connectionMode!==t.connectionMode)).concat(o)),o}async deleteTunnelEndpoints(e,t,n,s){const r=`${p}/${t}`,o=await this.sendTunnelRequest("DELETE",e,R,r,void 0,n,void 0,!0,s);return o&&e.endpoints&&(e.endpoints=e.endpoints.filter((e=>e.id!==t))),o}async listUserLimits(e){return await this.sendRequest("GET",void 0,"/userlimits",void 0,void 0,void 0,void 0,e)||[]}async listTunnelPorts(e,t,n){const s=await this.sendTunnelRequest("GET",e,$,h,void 0,t,void 0,void 0,n);return s.value&&s.value.forEach(m),s.value}async getTunnelPort(e,t,n,r){this.raiseReportProgress(s.TunnelProgress.StartingGetTunnelPort);const o=`${h}/${t}`,i=await this.sendTunnelRequest("GET",e,$,o,void 0,n,void 0,void 0,r);return m(i),this.raiseReportProgress(s.TunnelProgress.CompletedGetTunnelPort),i}async createTunnelPort(e,t,n,r){this.raiseReportProgress(s.TunnelProgress.StartingCreateTunnelPort),t=this.convertTunnelPortForRequest(e,t);const o=`${h}/${t.portNumber}`;(n=n||{}).additionalHeaders=n.additionalHeaders||{},n.additionalHeaders["If-Not-Match"]="*";const i=await this.sendTunnelRequest("PUT",e,y,o,void 0,n,t,void 0,r);return e.ports=e.ports||[],e.ports=e.ports.filter((e=>e.portNumber!==t.portNumber)).concat(i).sort(v),m(i),this.raiseReportProgress(s.TunnelProgress.CompletedCreateTunnelPort),i}async updateTunnelPort(e,t,n,s){if(t.clusterId&&e.clusterId&&t.clusterId!==e.clusterId)throw new Error("Tunnel port cluster ID is not consistent.");(n=n||{}).additionalHeaders=n.additionalHeaders||{},n.additionalHeaders["If-Match"]="*";const r=t.portNumber,o=`${h}/${r}`;t=this.convertTunnelPortForRequest(e,t);const i=await this.sendTunnelRequest("PUT",e,y,o,void 0,n,t,void 0,s);return w(t,i),m(i),e.ports=e.ports||[],e.ports=e.ports.filter((e=>e.portNumber!==t.portNumber)).concat(i).sort(v),i}async createOrUpdateTunnelPort(e,t,n,s){t=this.convertTunnelPortForRequest(e,t);const r=`${h}/${t.portNumber}`,o=await this.sendTunnelRequest("PUT",e,y,r,void 0,n,t,void 0,s);return e.ports=e.ports||[],e.ports=e.ports.filter((e=>e.portNumber!==t.portNumber)).concat(o).sort(v),m(o),o}async deleteTunnelPort(e,t,n,s){const r=`${h}/${t}`,o=await this.sendTunnelRequest("DELETE",e,y,r,void 0,n,void 0,!0,s);return o&&e.ports&&(e.ports=e.ports.filter((e=>e.portNumber!==t)).sort(v)),o}async listClusters(e){return await this.sendRequest("GET",void 0,"/clusters",void 0,void 0,void 0,!1,e)}async sendTunnelRequest(e,t,n,r,o,i,a,l,u,c=!1){this.raiseReportProgress(s.TunnelProgress.StartingRequestUri);const d=await this.buildUriForTunnel(t,r,o,i,c);this.raiseReportProgress(s.TunnelProgress.StartingRequestConfig);const p=await this.getAxiosRequestConfig(t,i,n);this.raiseReportProgress(s.TunnelProgress.StartingSendTunnelRequest);try{const t=await this.request(e,d,a,p,l,u);return this.raiseReportProgress(s.TunnelProgress.CompletedSendTunnelRequest),t}catch(e){if(/certificate/i.test(e.message)){const t=e.message;throw new Error("Tunnel service HTTPS certificate is invalid. This may be caused by the use of a self-signed certificate or a firewall intercepting the connection. "+t+". ")}throw e}}async sendRequest(e,t,n,r,o,i,a,l){this.raiseReportProgress(s.TunnelProgress.StartingSendTunnelRequest);const u=await this.buildUri(t,n,r,o),c=await this.getAxiosRequestConfig(void 0,o);try{const t=await this.request(e,u,i,c,a,l);return this.raiseReportProgress(s.TunnelProgress.CompletedSendTunnelRequest),t}catch(e){if(/certificate/i.test(e.message))throw new Error("Tunnel service HTTPS certificate is invalid. This may be caused by the use of a self signed certificate or a firewall intercepting the connection.");throw e}}async checkNameAvailablility(e,t){e=encodeURI(e);const n=await this.buildUri(void 0,`${d}/${e}:checkNameAvailability`),s={httpsAgent:this.httpsAgent,adapter:this.adapter};return await this.request("GET",n,void 0,s,void 0,t)}raiseReportProgress(e){const t={progress:e};this.reportProgressEmitter.fire(t)}getResponseErrorMessage(e,t){var n,r,o,i,a,l;let u="";if(t.aborted?(e.code="ECONNABORTED",u=`ECONNABORTED: (signal aborted) ${e.message}`):"ECONNABORTED"===e.code&&(u=`ECONNABORTED: (timeout) ${e.message}`),null===(n=e.response)||void 0===n?void 0:n.data){const t=e.response.data;(t.title||t.detail)&&(u=`Tunnel service error: ${t.title}`,t.detail&&(u+=" "+t.detail),t.errors&&(u+=JSON.stringify(t.errors)))}if(!u&&e.response&&e.response.status&&e.response.status>=400&&e.response.status<500&&e.response.headers){const t=e.response.headers,n=t["X-Served-By"]||t["x-served-by"];if(!/tunnels-/.test(n)){const t=new URL(null!==(o=null===(r=e.config)||void 0===r?void 0:r.url)&&void 0!==o?o:s.TunnelServiceProperties.production.serviceUri).host;u=`The tunnel request resulted in ${e.response.status} status, but the request did not reach the tunnel service. This may indicate the domain '${t}' is blocked by a firewall.`}}u||(u=e.response?`Tunnel service returned status code: ${e.response.status} ${e.response.statusText}`:null!==(a=null!==(i=null==e?void 0:e.message)&&void 0!==i?i:e)&&void 0!==a?a:"Unknown tunnel service request error.");const c="VsSaaS-Request-Id";return(null===(l=e.response)||void 0===l?void 0:l.headers)&&e.response.headers[c]&&(u+=`\nRequest ID: ${e.response.headers[c]}`),u}async buildUri(e,t,n,s){if(void 0===e&&this.userTokenCallback){let t=await this.userTokenCallback();if(t&&t.startsWith("tunnelplan")){t=t.replace("tunnelplan ","");const n=l.TunnelPlanTokenProperties.tryParse(t);null!==n&&n.clusterId&&(e=n.clusterId)}}let r=this.baseAddress;if(e){const t=new URL(r),n=parseInt(t.port,10);if("localhost"===t.hostname||t.hostname.startsWith(`${e}.`)){if("https:"===t.protocol&&e.startsWith("localhost")&&n%10>0){const s=parseInt(e.substring(9),10);s>0&&s<10&&(t.port=(n-n%10+s).toString(),r=t.toString())}}else t.hostname=`${e}.${t.hostname}`.replace("global.",""),r=t.toString()}r=`${r.replace(/\/$/,"")}${t}`;const o=this.tunnelRequestOptionsToQueryString(s,n);return o&&(r+=`?${o}`),r}buildUriForTunnel(e,t,n,s,r=!1){let o="";if(!e.clusterId&&!r||!e.tunnelId)throw new Error("Tunnel object must include a tunnel ID always and cluster ID for non creates.");if(o=`${d}/${e.tunnelId}`,null==s?void 0:s.additionalQueryParameters)for(const[e,t]of Object.entries(s.additionalQueryParameters))n?n+=`&${e}=${t}`:n=`${e}=${t}`;return this.buildUri(e.clusterId,o+(t||""),n,s)}async getAxiosRequestConfig(e,t,n){const s={};if(t&&t.accessToken&&(s[T]=`${r.TunnelAuthenticationSchemes.tunnel} ${t.accessToken}`),!(T in s)&&this.userTokenCallback){const e=await this.userTokenCallback();e&&(s[T]=e)}if(!(T in s)){const t=o.TunnelAccessTokenProperties.getTunnelAccessToken(e,n);t&&(s[T]=`${r.TunnelAuthenticationSchemes.tunnel} ${t}`)}const a=e=>{if(e)for(const[t,n]of Object.entries(e))s[t]=n};a(this.additionalRequestHeaders),a(null==t?void 0:t.additionalHeaders);const l=s["User-Agent"]?s["User-Agent"]+" ":"";s["User-Agent"]=`${l}${this.userAgents} ${i.tunnelSdkUserAgent}`;const u=Object.assign(Object.assign({headers:s},this.httpsAgent&&{httpsAgent:this.httpsAgent}),this.adapter&&{adapter:this.adapter});return!1===(null==t?void 0:t.followRedirects)&&(u.maxRedirects=0),u}convertTunnelForRequest(e){var t;return{tunnelId:e.tunnelId,name:e.name,domain:e.domain,description:e.description,labels:e.labels,options:e.options,customExpiration:e.customExpiration,accessControl:e.accessControl?{entries:e.accessControl.entries.filter((e=>!e.isInherited))}:void 0,endpoints:e.endpoints,ports:null===(t=e.ports)||void 0===t?void 0:t.map((t=>this.convertTunnelPortForRequest(e,t)))}}convertTunnelPortForRequest(e,t){if(t.clusterId&&e.clusterId&&t.clusterId!==e.clusterId)throw new Error("Tunnel port cluster ID does not match tunnel.");if(t.tunnelId&&e.tunnelId&&t.tunnelId!==e.tunnelId)throw new Error("Tunnel port tunnel ID does not match tunnel.");return{portNumber:t.portNumber,protocol:t.protocol,isDefault:t.isDefault,description:t.description,labels:t.labels,sshUser:t.sshUser,options:t.options,accessControl:t.accessControl?{entries:t.accessControl.entries.filter((e=>!e.isInherited))}:void 0}}tunnelRequestOptionsToQueryString(e,t){const n={},r=[];e&&(e.includePorts&&(n.includePorts=["true"]),e.includeAccessControl&&(n.includeAccessControl=["true"]),e.tokenScopes&&(s.TunnelAccessControl.validateScopes(e.tokenScopes,void 0,!0),n.tokenScopes=e.tokenScopes),e.forceRename&&(n.forceRename=["true"]),e.labels&&(n.labels=e.labels,e.requireAllLabels&&(n.allLabels=["true"])),e.limit&&(n.limit=[e.limit.toString()]),r.push(...Object.keys(n).map((e=>`${e}=${n[e].map(encodeURIComponent).join(",")}`)))),t&&r.push(t),r.push(`api-version=${this.apiVersion}`);return r.join("&")}async axiosRequest(e,t){return await a.default.request(e)}async request(e,t,n,s,r,o){var i,a;this.trace(`${e} ${t}`),s.headers&&this.traceHeaders(s.headers),this.traceContent(n);const l=e=>{this.trace(`${e.status} ${e.statusText}`),this.traceHeaders(e.headers),this.traceContent(e.data)};let u;const c=new AbortController;let d;try{s.url=t,s.method=e,s.data=n,s.signal=((null==o?void 0:o.isCancellationRequested)?c.abort("Cancelled: CancellationToken cancel requested."):o?u=o.onCancellationRequested((()=>c.abort("Cancelled: CancellationToken cancel requested."))):d=setTimeout((()=>c.abort("Cancelled: default request timeout reached.")),2e4),c.signal),s.timeout=2e4;const r=await this.axiosRequest(s,o);return l(r),"DELETE"===e||r.data}catch(t){if(!(t instanceof Error&&t.isAxiosError))throw t;const n=t;if(n.response&&(l(n.response),r&&404===n.response.status))return"DELETE"!==e&&null;throw n.message=this.getResponseErrorMessage(n,c.signal),delete n.request,n.response&&(null===(i=n.config)||void 0===i||delete i.httpAgent,null===(a=n.config)||void 0===a||delete a.httpsAgent,delete n.response.request),n}finally{d&&clearTimeout(d),null==u||u.dispose()}}traceHeaders(e){for(const[t,n]of Object.entries(e)){if("Authorization"===t)return void this.traceAuthorizationHeader(t,n);this.trace(`${t}: ${null!=n?n:""}`)}}traceAuthorizationHeader(e,t){if("string"!=typeof t)return;const n=t.indexOf(" ");if(n<0)return void this.trace(`${e}: [${t.length}]`);const s=t.substring(0,n),i=t.substring(n+1);if(s.toLowerCase()===r.TunnelAuthenticationSchemes.tunnel.toLowerCase()){const t=o.TunnelAccessTokenProperties.tryParse(i);if(t)return void this.trace(`${e}: ${s} <${t}>`)}this.trace(`${e}: ${s} <token>`)}traceContent(e){"object"==typeof e&&(e=JSON.stringify(e,void 0,"  ")),"string"==typeof e&&this.trace(E.replaceTokensInContent(e))}static replaceTokensInContent(e){var t;const n=/"(eyJ[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+)"/;let s=n.exec(e);for(;s;){let r=s[1];const i=o.TunnelAccessTokenProperties.tryParse(r);r=null!==(t=null==i?void 0:i.toString())&&void 0!==t?t:"token",e=e.substring(0,s.index+1)+"<"+r+">"+e.substring(s.index+s[0].length-1),s=n.exec(e)}return e}}t.TunnelManagementHttpClient=E}}]);