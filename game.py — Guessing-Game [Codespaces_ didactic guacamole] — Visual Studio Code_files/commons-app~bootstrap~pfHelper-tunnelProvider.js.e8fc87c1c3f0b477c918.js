"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[772],{97339:function(e,t,n){var o=this&&this.__createBinding||(Object.create?function(e,t,n,o){void 0===o&&(o=n);var r=Object.getOwnPropertyDescriptor(t,n);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,o,r)}:function(e,t,n,o){void 0===o&&(o=n),e[o]=t[n]}),r=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&o(t,e,n);return r(t,e),t},s=this&&this.__awaiter||function(e,t,n,o){return new(n||(n=Promise))((function(r,i){function s(e){try{c(o.next(e))}catch(e){i(e)}}function l(e){try{c(o.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,l)}c((o=o.apply(e,t||[])).next())}))},l=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.isKnownNetworkError=t.privacyStringToPortPrivacy=t.accessControlToPrivacy=t.AllowOrgAccess=t.AllowAnonymousAccess=t.protocolToTunnelProtocol=t.TunnelProvider=t.PortPrivacyNotAllowed=void 0;const c=l(n(43627)),a=n(15663),u=i(n(94027)),d=n(49206),h=n(76994),p=n(73551),y=n(5037),v=n(74061),P=n(11565),T=n(43369),m=n(5823),f=n(25291),g=n(56478),w=30*f.TIME_SECOND_MS;class C extends Error{}t.PortPrivacyNotAllowed=C;const b=[/vsls\-agent/,/vscode\-remote(?![\\\/]extensions)/];class A extends f.DisposableClass{constructor(e){super(e.trace.createChild("tunnel-provider")),this.options=e,this.tunnels=new Map,this.tunnelClientLock=new c.default,this.listeningForPortEvents=!1,this.webSocketErrorRegex=/Failed to connect to relay url/,this.createNewTunnelClient=()=>{let e=!1;this.tunnelClient&&(this.tunnelClient.dispose(),e=!0);const t=new p.TunnelRelayTunnelClient(((e,t,n,o)=>{o?this.trace.error(`tunnelClient ${e} ${t}: ${n}`,o):this.trace.verbose(`tunnelClient ${e} ${t}: ${n}`)}),this.managementClient);return t.acceptLocalConnectionsForForwardedPorts=!1,this.listeningForPortEvents=!1,this.subscribeToEvents(t),this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.TunnelClientCreated,{disposedOldTunnelClient:e}]),t},this.tunnelFactory=(e,t)=>s(this,void 0,void 0,(function*(){const{remoteAddress:{port:n,host:o},protocol:r,privacy:i}=e,l=(0,d.v4)();this.trace.info("Tunnel factory called",e,t);const c=E(r);let a={Action:m.TelemetryActionTypes.OpenTunnel,port:n,host:o,tunnelProtocol:c,privacy:i,isInternal:!1,elevationRequired:null==t?void 0:t.elevationRequired,RootActivityId:l};this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.ActionStart,a]);let u=i?R(i):void 0;try{const i=this.tunnels.get(n);if(a.tunnelAction=i?"update":"create",i&&(a.existingTunnelProtocol=i.tunnelPort.protocol,(0,f.isInternalPort)(i.tunnelPort.labels)))throw new P.TunnelProviderError(`Forwarding internal port ${n} is not allowed`);const l=yield this.forwardPort(n,c,u);u=S(l.tunnelPort.accessControl);let d={host:m.LOCALHOST_HOST_IP,port:n};if(this.options.acceptLocalConnections){this.trace.info(`Accepting local connections for port ${n}`);const o=l.tunnelPort.portForwardingUris&&l.tunnelPort.portForwardingUris[l.tunnelPort.portForwardingUris.length-1];if(o&&!this.shouldUseLocalPortForwarding(u,c))this.trace.info(`Using primary port forwarding uri ${o}`),d=o,a.localAddress=d;else{if(!(null==t?void 0:t.elevationRequired)){const t=yield this.forwardPortLocally(e,l);d.port=t}a.localAddress=`${d.host}:${d.port}`}}const h={remoteAddress:{port:n,host:o},protocol:r,localAddress:d,privacy:u,onDidDispose:l.onDidDisposeEmitter.event,dispose:()=>s(this,void 0,void 0,(function*(){yield this.stopForwardingPort(n)}))};return a.Result=m.TelemetryResultTypes.Success,h}catch(e){this.trace.error("failed to create tunnel: ",e),a.Result=N(e);const t=(0,f.errorToObject)(e);throw a=Object.assign(Object.assign({},a),t),e}finally{a.resolvedPrivacy=u,a.connectionStatus=this.tunnel.status,a.tunnelClientStatus=this.tunnelClient.connectionStatus,a.tunnelStatus=this.tunnel.status,a.tunnelsMapSize=this.tunnels.size;const e=(0,f.addLatencyDetailsToEvent)(a);this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.ActionStop,e])}})),this.showPortCandidate=(e,t,n)=>Promise.resolve(!b.some((e=>n.match(e)))),this.features={public:!1,elevation:!1,privacyOptions:[]},this.subscribeToEvents=e=>{e.connectionStatusChanged((e=>s(this,void 0,void 0,(function*(){e.status===p.ConnectionStatus.Disconnected&&(this.trace.verbose(`Tunnel client disconnected, recreating and reconnecting: ${e.disconnectError}`),this.tunnelClient=this.createNewTunnelClient(),yield this.connectTunnelClient(!0))})))),e.retryingTunnelConnection((e=>{const t=(0,f.errorToObject)(e.error);this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.TunnelConnectionRetry,Object.assign({delay:e.delayMs,retry:e.retry},t)])})),e.onReportProgress((e=>{this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.TunnelProgressReport,Object.assign(Object.assign({},e),{source:"tunnel-client"})])})),e.forwardedPortConnecting((e=>{this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.ForwardedPortConnecting,Object.assign({},e)])}))};const{tunnelProperties:t,privacySettings:n,allowUnsafeConnections:o,acceptLocalConnections:r,shouldListenForPortEvents:i,managementClient:l,tunnelClient:a}=e,h=(0,d.v4)();let g={Action:m.TelemetryActionTypes.SetupTunnelProvider,tunnelId:null==t?void 0:t.tunnelId,clusterId:null==t?void 0:t.clusterId,domain:null==t?void 0:t.domain,privacySettings:n.join(", "),allowUnsafeConnections:o,acceptLocalConnections:r,shouldListenForPortEvents:i,RootActivityId:h};this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.ActionStart,g]),this.mainConnectionReference=new f.DisposableClass(this.trace),this.mainConnectionReference.addToDisposables(this);try{let e;(0,f.assertDefined)(t,new Error("Tunnel Properties must be defined")),this.options.allowUnsafeConnections&&!this.options.isRunningInWeb&&(this.trace.info("Allowing unsafe connections"),e=new u.Agent({rejectUnauthorized:!1})),this.pushPrivacyOptions(n),this.managementClient=null!=l?l:new v.TunnelManagementHttpClient({name:f.BASIS_CS_EXTENSION_NAME},v.ManagementApiVersions.Version20230927preview,void 0,t.serviceUri,e),this.managementClient.onReportProgress&&this.managementClient.onReportProgress((e=>{this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.TunnelProgressReport,Object.assign(Object.assign({},e),{source:"management-client"})])})),this.tunnelClient=null!=a?a:this.createNewTunnelClient(),this.tunnel={tunnelId:t.tunnelId,clusterId:t.clusterId,domain:t.domain,accessTokens:{[y.TunnelAccessScopes.Connect]:t.connectAccessToken,[y.TunnelAccessScopes.ManagePorts]:t.managePortsAccessToken}};try{const e=v.TunnelAccessTokenProperties.tryParse(t.managePortsAccessToken),n=v.TunnelAccessTokenProperties.tryParse(t.connectAccessToken);g.parsedManagementToken=JSON.stringify(e),g.parsedConnectToken=JSON.stringify(n)}catch(e){this.trace.error("Failed to parse access tokens: ",e)}g.Result=m.TelemetryResultTypes.Success}catch(e){this.trace.error("Failed to setup tunnel provider: ",e),_(e)&&(e=new P.NetworkError(e.message)),g.Result=N(e);const t=(0,f.errorToObject)(e);throw g=Object.assign(Object.assign({},g),t),e}finally{const e=(0,f.addLatencyDetailsToEvent)(g);this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.ActionStop,e])}}connectTunnelClient(e,t){return s(this,void 0,void 0,(function*(){if(!this.isDisposed)return this.withConnectedTunnelClient((t=>s(this,void 0,void 0,(function*(){this.trace.info("Tunnel client connected, is reconnect: "+(e?"true":"false"))}))),"client_"+(e?"reconnect":"initial_connect"),void 0,void 0,t);this.trace.info("Not connecting tunnel client because the provider is disposed")}))}forwardPort(e,t,n,o=[m.TPortType.User]){return s(this,void 0,void 0,(function*(){if(n&&!this.options.privacySettings.includes(n))throw new C(`Unallowed port privacy: ${n}. Only ${this.options.privacySettings} is allowed.`);const r=this.tunnels.get(e);return yield this.createOrReuseTunnelPort(r,e,o,t,n)}))}forwardPortLocally(e,t){var n;return s(this,void 0,void 0,(function*(){const o=e.remoteAddress.port;if(this.trace.info(`Forwarding port ${o} locally`),!t&&!(t=this.tunnels.get(o)))throw new Error(`Tunnel for port ${o} does not exist, call tunnelFactory before forwarding locally`);if(t.localPortForwarder)return this.trace.info(`Port ${o} is already being forwarded locally`),t.localPortForwarder.localPort;let r=g.PortType.User;const i=t.tunnelPort.labels;(0,f.isInternalPort)(i)&&(r=g.PortType.VSCode);const s=null!==(n=this.options.getLocalPortHostAddress)&&void 0!==n?n:()=>m.LOCALHOST_HOST_IP,l=new g.LocalPortForwarder(this.trace,this,e.localAddressPort||o,o,E(t.tunnelPort.protocol),s(i),r);yield l.start(),this.trace.info(`Using local port ${l.localPort}`),(0,f.isInternalPort)(i)&&(this.trace.info(`Setting main connection reference for remote port ${o} to local port ${l.localPort}`),l.addToDisposables(this.mainConnectionReference),yield this.revivePorts(),this.setupPortEventListeners());const c=Object.assign(Object.assign({},t),{localPortForwarder:l});return this.tunnels.set(o,c),l.localPort}))}shouldUseLocalPortForwarding(e,t){var n;if(e!==m.PortPrivacy.Private)return this.trace.info(`Port ${e} is not private, not forwarding locally`),!1;const o=null!==(n=this.options.shouldUseLocalPortForwardingForHttps)&&void 0!==n?n:()=>!1;return t===y.TunnelProtocol.Https&&o()?(this.trace.info(`Port ${e} is using HTTPS and port forwarding service is enabled, not forwarding locally`),!1):(this.trace.info("Forwarding port locally"),!0)}addForwardedPort(e){return s(this,void 0,void 0,(function*(){this.trace.verbose(`Adding forwarded port ${e}`);const t=this.tunnels.get(e);if(t)return this.trace.verbose(`Forwarded port ${e} already exists`),t;let n;try{n=yield this.withTunnelManagementClient((t=>t.getTunnelPort(this.tunnel,e)),"get_tunnel_port")}catch(e){return void this.trace.error("Failed to get tunnel port",e)}if(!n)return void this.trace.verbose(`Forwarded port ${e} doesn't exist`);if(!this.shouldAllowPort(n.portNumber,n.labels))return void this.trace.info(`Not adding internal port ${e}`);const o={tunnelPort:n,onDidDisposeEmitter:new h.Emitter};return this.tunnels.set(n.portNumber,o),yield this.openWorkspaceTunnel(n),this.trace.verbose(`Added port: ${n.portNumber}`),o}))}openWorkspaceTunnel(e){return s(this,void 0,void 0,(function*(){const t=e.accessControl?function(e){const t=S(e);return t===m.PortPrivacy.Public?"public":t===m.PortPrivacy.Org?"org":m.PortPrivacy.Private}(e.accessControl):"private";if((0,f.isInternalPort)(e.labels))return void this.trace.verbose(`Not opening workspace tunnel for internal port ${e.portNumber}`);const n=function(e){return"https"===e?e:"http"}(e.protocol);yield this.options.openTunnel({remoteAddress:{port:e.portNumber,host:"localhost"},privacy:t,protocol:n})}))}get mainConnection(){return(0,f.assertDefined)(this.mainConnectionReference,"mainConnectionReference is not defined."),this.mainConnectionReference}forwardInternalPort(e){return s(this,void 0,void 0,(function*(){const t=(0,d.v4)();let n={Action:m.TelemetryActionTypes.OpenTunnel,port:e,host:m.LOCALHOST_HOST_IP,privacy:m.PortPrivacy.Private,tunnelProtocol:y.TunnelProtocol.Https,isInternal:!0,elevationRequired:!1,RootActivityId:t};this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.ActionStart,n]);try{let t=yield this.addForwardedPort(e);n.alreadyExists=!!t,t||(t=yield this.forwardPort(e,y.TunnelProtocol.Https,m.PortPrivacy.Private,[m.TPortType.Internal]));let o=e;if(e!==f.CODESPACES_INTERNAL_WEB_PORT){const o=yield this.forwardPortLocally({remoteAddress:{host:m.LOCALHOST_HOST_IP,port:e}},t);n.localAddress=`${m.LOCALHOST_HOST_IP}:${o}`}return n.Result=m.TelemetryResultTypes.Success,o}catch(e){this.trace.error("failed to create tunnel: ",e),n.Result=N(e);const t=(0,f.errorToObject)(e);throw n=Object.assign(Object.assign({},n),t),e}finally{n.connectionStatus=this.tunnel.status,n.tunnelClientStatus=this.tunnelClient.connectionStatus,n.tunnelStatus=this.tunnel.status,n.tunnelsMapSize=this.tunnels.size;const e=(0,f.addLatencyDetailsToEvent)(n);this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.ActionStop,e])}}))}revivePorts(){return s(this,void 0,void 0,(function*(){this.trace.verbose("Reviving ports...");const e=yield this.managementClient.listTunnelPorts(this.tunnel);this.options.telemetry.addContextProperty("listedTunnelPorts",e.length);for(const t of e){const e={tunnelPort:t,onDidDisposeEmitter:new h.Emitter};this.tunnels.set(t.portNumber,e),this.openWorkspaceTunnel(t),this.trace.verbose(`Revived port: ${t.portNumber}`)}}))}stopForwardingPort(e,t=!0){return s(this,void 0,void 0,(function*(){let n={currentTunnelStatus:this.tunnelClient.connectionStatus,port:e,Result:m.TelemetryResultTypes.Success};try{this.trace.verbose(`Stopping forwarded port ${e}`);const o=this.tunnels.get(e);if(!o)return void this.trace.verbose(`Forwarded port ${e} does not exist locally`);o.localPortForwarder&&(this.trace.info(`Stopping local port forwarder for port ${e}`),yield o.localPortForwarder.dispose(),this.trace.info(`Stopped local port forwarder for port ${e}`)),t?(this.trace.info(`Deleting port ${e} from the tunnel`),yield this.withTunnelManagementClient((t=>t.deleteTunnelPort(this.tunnel,e)),"delete_tunnel_port"),this.trace.info(`Deleted port ${e} from the tunnel`),this.tunnels.delete(e),yield this.refreshPorts(e)):this.tunnels.delete(e),this.trace.info(`Stopped forwarding port ${e}`),o.onDidDisposeEmitter.fire(),n.portExists=!!o}catch(e){this.trace.error("Error stopping port",e),n.Result=N(e);const t=(0,f.errorToObject)(e);throw n=Object.assign(Object.assign({},n),t),e}finally{this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.DeletePort,n])}}))}refreshPorts(e,t=[]){return s(this,void 0,void 0,(function*(){yield this.withConnectedTunnelClient((e=>e.refreshPorts()),"refresh_ports",e,t)}))}createDevTunnel(e,t){const n={tunnelPort:e,onDidDisposeEmitter:null!=t?t:new h.Emitter};return this.tunnels.set(e.portNumber,n),n}createOrReuseTunnelPort(e,t,n,o,r,i=0){return s(this,void 0,void 0,(function*(){if(this.trace.info(`Creating or reusing ${o}/${t} with privacy '${r}', attempt ${i}`),e){const n=e.tunnelPort;if(function(e,t,n){return!(t&&e.protocol!==t||n&&S(e.accessControl)!==n)}(n,o,r))return this.trace.info(`${n.protocol}/${t} already exists with privacy '${S(n.accessControl)}' so reusing the existing port`),e;this.trace.info(`${n.protocol}/${t} already exists but doesn't match requested settings, deleting and recreating`),yield this.stopForwardingPort(t)}const s=null!=o?o:y.TunnelProtocol.Http,l=null!=r?r:m.PortPrivacy.Private,c={portNumber:t,protocol:s,accessControl:O(l),labels:n};try{const o=yield this.withTunnelManagementClient((e=>e.createTunnelPort(this.tunnel,c)),"create_tunnel_port"),r=this.createDevTunnel(o,null==e?void 0:e.onDidDisposeEmitter);return yield this.refreshPorts(t,n),this.trace.info(`Created port ${s}/${t} with privacy '${l}'`),r}catch(e){if(i>=2)throw e;if(e.response&&409==e.response.status){this.trace.info(`Port ${s}/${t} already exists, trying to get existing tunnel port`),yield this.refreshPorts(t,n);const e=yield this.withTunnelManagementClient((e=>e.getTunnelPort(this.tunnel,t)),"get_tunnel_port");let l;return e&&(l=this.createDevTunnel(e)),yield this.createOrReuseTunnelPort(l,t,n,o,r,i+1)}throw e}}))}withConnectedTunnelClient(e,t,n=0,o=[],r){return s(this,void 0,void 0,(function*(){yield this.tunnelClientLock.acquire("tunnelClient",(e=>s(this,void 0,void 0,(function*(){if(this.tunnelClient.connectionStatus!==p.ConnectionStatus.Connected){const n=(0,d.v4)();let o={Action:m.TelemetryActionTypes.ConnectTunnelClient,RootActivityId:n,currentTunnelStatus:this.tunnelClient.connectionStatus,operationType:t};this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.ActionStart,o]),this.trace.info("Tunnel client is unconnected, fetching tunnel and connecting",this.tunnel),this.tunnelClient.connectionStatus===p.ConnectionStatus.Disconnected&&(this.tunnelClient=this.createNewTunnelClient(),this.trace.info("Recreated tunnel client",this.tunnel),o.newTunnel=!0);try{const e=yield this.withTunnelManagementClient((e=>e.getTunnel(this.tunnel,{includePorts:!0})),"get_tunnel");e&&(e.accessTokens=this.tunnel.accessTokens,yield this.connectTunnelClientWithRetry(e,n,r)),o.Result=m.TelemetryResultTypes.Success}catch(t){this.trace.error("Error connecting tunnel client",t),_(t)&&(t=new P.NetworkError(t.message)),o.Result=N(t);const n=(0,f.errorToObject)(t);o=Object.assign(Object.assign({},o),n),e(t)}finally{o.currentTunnelStatus=this.tunnelClient.connectionStatus;const e=(0,f.addLatencyDetailsToEvent)(o);this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.ActionStop,e])}}e()}))));const i=yield this.tunnelClientRetryOnException(e,o,n);return this.options.isRunningInWeb&&this.setupPortEventListeners(),i}))}withTunnelManagementClient(e,t){var n;return s(this,void 0,void 0,(function*(){try{return yield(0,f.withRetries)((()=>s(this,void 0,void 0,(function*(){return yield e(this.managementClient)}))),{retries:2,retryDelay:250,shouldStopRetries:e=>s(this,void 0,void 0,(function*(){const t=null==e?void 0:e.code;return!/ECONNABORTED/.test(e.message)&&"ECONNABORTED"!==t})),isAggregateError:!1})}catch(e){const o=null===(n=e.response)||void 0===n?void 0:n.status;this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.TunnelOperationError,Object.assign(Object.assign({},(0,f.errorToObject)(e)),{errorType:null==e?void 0:e.errorType,operationType:`tunnel_management_client_${t}`,responseStatus:o})]);const r=null==e?void 0:e.code;if(/ECONNABORTED/.test(e.message)||"ECONNABORTED"===r)throw new P.ConnectionAbortedError(e.message);throw _(e)&&(e=new P.NetworkError(e.message)),e}}))}dispose(){const e=Object.create(null,{dispose:{get:()=>super.dispose}});return s(this,void 0,void 0,(function*(){e.dispose.call(this);for(const e of this.tunnels.values())yield this.stopForwardingPort(e.tunnelPort.portNumber,!1);yield this.tunnelClient.dispose()}))}getStreamFromPort(e,t,n){return s(this,void 0,void 0,(function*(){try{return this.trace.info(`Getting stream from port ${e} with protocol ${t}`),yield this.forwardPort(e,t,void 0,n),yield this.withConnectedTunnelClient((t=>s(this,void 0,void 0,(function*(){return t.waitForForwardedPort(e)}))),"wait_for_forwarded_port",e),yield this.withConnectedTunnelClient((t=>s(this,void 0,void 0,(function*(){return yield t.connectToForwardedPort(e)}))),"connect_to_forwarded_port",e)}catch(e){throw new P.ConnectionError(e.message)}}))}pushPrivacyOptions(e){e.forEach((e=>{switch(e){case m.PortPrivacy.Private:this.features.privacyOptions.push({id:e.toString(),label:f.PORT_FORWARDING_PRIVACY_PRIVATE,themeIcon:"lock"});break;case m.PortPrivacy.Org:this.features.privacyOptions.push({id:e.toString(),label:f.PORT_FORWARDING_PRIVACY_PRIVATE_ORG,themeIcon:"organization"});break;case m.PortPrivacy.Public:this.features.privacyOptions.push({id:e.toString(),label:f.PORT_FORWARDING_PRIVACY_PUBLIC,themeIcon:"eye"})}}))}setupPortEventListeners(){var e,t;this.options.shouldListenForPortEvents&&!this.listeningForPortEvents&&(this.mainConnectionReference||this.options.isRunningInWeb)&&(null===(e=this.tunnelClient.forwardedPorts)||void 0===e||e.onPortAdded((e=>s(this,void 0,void 0,(function*(){e.port.remotePort?(this.trace.verbose(`Received port added event for port ${e.port.remotePort}`),yield this.addForwardedPort(e.port.remotePort)):this.trace.verbose("Attempted to add port without remote port value")})))),null===(t=this.tunnelClient.forwardedPorts)||void 0===t||t.onPortRemoved((e=>s(this,void 0,void 0,(function*(){e.port.remotePort?(this.trace.verbose(`Received port removed event for port ${e.port.remotePort}`),yield this.stopForwardingPort(e.port.remotePort,!1)):this.trace.verbose("Attempted to remove port without remote port value")})))),this.listeningForPortEvents=!0)}connectTunnelClientWithRetry(e,t,n=w){return s(this,void 0,void 0,(function*(){return yield(0,f.withRetries)((()=>s(this,void 0,void 0,(function*(){let o=setTimeout((()=>{this.options.telemetry.sendTelemetry([T.CodespacesTelemetryEventNames.LongRunningClientConnection,{RootActivityId:t,currentTunnelStatus:this.tunnelClient.connectionStatus,alertTimeoutMs:n}])}),n);try{yield this.tunnelClient.connect(e)}catch(e){throw e}finally{clearTimeout(o)}}))),{retries:2,retryDelay:250,shouldStopRetries:e=>s(this,void 0,void 0,(function*(){return/Not connected/.test(e.message)||/disposed/.test(e.message)?(this.tunnelClient=this.createNewTunnelClient(),!1):!this.webSocketErrorRegex.test(e.message)||(this.tunnelClient=this.createNewTunnelClient(),!1)})),isAggregateError:!1})}))}tunnelClientRetryOnException(e,t,n){return s(this,void 0,void 0,(function*(){return yield(0,f.withRetries)((()=>s(this,void 0,void 0,(function*(){return yield e(this.tunnelClient)}))),{retries:1,retryDelay:250,shouldStopRetries:e=>s(this,void 0,void 0,(function*(){var t;const n=null==e?void 0:e.response;if(/Not connected/.test(e.message)||/disposed/.test(e.message))return this.tunnelClient=this.createNewTunnelClient(),yield this.connectTunnelClient(!0),!1;if(n&&429===n.status){const e=parseInt(null===(t=n.headers)||void 0===t?void 0:t["x-ms-ratelimit-retry-after"],10);return e&&(yield(0,f.wait)(e*f.TIME_SECOND_MS-250)),!1}return!0})),isAggregateError:!1})}))}shouldAllowPort(e,t){return(0,f.isInternalPort)(t)&&this.options.skipInternalPorts?(this.trace.verbose(`Skipping port ${e} because it is an internal port`),!1):e!==f.CODESPACES_INTERNAL_PORT||(this.trace.verbose(`Skipping port ${e} because it is the internal (non-web) port`),!1)}}function E(e){return e&&"http"!==e?"https"===e?y.TunnelProtocol.Https:y.TunnelProtocol.Auto:y.TunnelProtocol.Http}function O(e){switch(e){case m.PortPrivacy.Public:return{entries:[t.AllowAnonymousAccess]};case m.PortPrivacy.Private:return{entries:[]};case m.PortPrivacy.Org:return{entries:[t.AllowOrgAccess]}}}function S(e){const t=e.entries.find((e=>e.type===y.TunnelAccessControlEntryType.Anonymous));if(t&&!0!==t.isDeny)return m.PortPrivacy.Public;const n=e.entries.find((e=>e.provider===v.TunnelAuthenticationSchemes.github));return n&&!0!==n.isDeny?m.PortPrivacy.Org:m.PortPrivacy.Private}function R(e){return"public"===e?m.PortPrivacy.Public:"org"===e?m.PortPrivacy.Org:m.PortPrivacy.Private}function _(e){return!!(/Network Error/.test(e.message)||/the request did not reach the tunnel service/.test(e.message)||/Tunnel service HTTPS certificate is invalid/.test(e.message)||/Failed to connect to relay url/.test(e.message)||/Forwarding internal port/.test(e.message)||/error.relayConnectionError/.test(e.message)||/error.relayServerError/.test(e.message)||/getaddrinfo/.test(e.message)||/500 handshakefailed/.test(e.message)||/400 bad request/.test(e.message)||/connect E/.test(e.message)||/write E/.test(e.message)||/read E/.test(e.message)||/Failed to establish a socket connection to proxies/.test(e.message)||/FortiClient/.test(e.message)||/Client network socket disconnected before secure TLS connection was established/.test(e.message)||(0,a.isNetworkError)(e))}function N(e){return e instanceof P.NetworkError||e instanceof P.WebSocketError||e instanceof P.ConnectionAbortedError?m.TelemetryResultTypes.UserError:m.TelemetryResultTypes.Failure}t.TunnelProvider=A,t.protocolToTunnelProtocol=E,t.AllowAnonymousAccess={type:y.TunnelAccessControlEntryType.Anonymous,subjects:[],scopes:["connect"]},t.AllowOrgAccess={type:y.TunnelAccessControlEntryType.Organizations,provider:v.TunnelAuthenticationSchemes.github,subjects:["1"],scopes:["connect"]},t.accessControlToPrivacy=S,t.privacyStringToPortPrivacy=R,t.isKnownNetworkError=_}}]);