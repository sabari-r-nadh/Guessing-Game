"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[417],{19773:(e,t,s)=>{var o=s(88538);Object.defineProperty(t,"__esModule",{value:!0}),t.TunnelRelayTunnelClient=t.webSocketSubProtocolv2=t.webSocketSubProtocol=void 0;const n=s(5037),i=s(81644),r=s(67322),c=s(51298),a=s(10712),h=s(31338),d=s(76994),l=s(11644),u=s(48577),S=s(93562);t.webSocketSubProtocol="tunnel-relay-client",t.webSocketSubProtocolv2="tunnel-relay-client-v2-dev";const w=(null==o?void 0:o.env)&&o.env.DEVTUNNELS_PROTOCOL_VERSION,p="1"===w?[t.webSocketSubProtocol]:"2"===w?[t.webSocketSubProtocolv2]:[t.webSocketSubProtocolv2,t.webSocketSubProtocol];class g extends u.TunnelConnectionSession{constructor(e,t){super(n.TunnelAccessScopes.Connect,p,e,t),this.portForwardingEmitter=new d.Emitter,this.sshSessionClosedEmitter=new d.Emitter,this.acceptLocalConnectionsForForwardedPortsValue=(0,a.isNode)(),this.localForwardingHostAddressValue="127.0.0.1",this.disconnectedStreams=new Map,this.connectionModes=[],this.portForwarding=this.portForwardingEmitter.event,this.sshSessionClosed=this.sshSessionClosedEmitter.event}get isSshSessionActive(){var e;return!!(null===(e=this.sshSession)||void 0===e?void 0:e.isConnected)}hasForwardedChannels(e){var t;if(!this.isSshSessionActive)return!1;const s=null===(t=this.sshSession)||void 0===t?void 0:t.activateService(r.PortForwardingService),o=null==s?void 0:s.remoteForwardedPorts,n=null==o?void 0:o.find((t=>t.remotePort===e));return!!n&&o.getChannels(n).length>0}get acceptLocalConnectionsForForwardedPorts(){return this.acceptLocalConnectionsForForwardedPortsValue}set acceptLocalConnectionsForForwardedPorts(e){if(e!==this.acceptLocalConnectionsForForwardedPortsValue){if(e&&!(0,a.isNode)())throw new Error("Cannot accept local connections for forwarded ports on this platform.");this.acceptLocalConnectionsForForwardedPortsValue=e,this.configurePortForwardingService()}}get localForwardingHostAddress(){return this.localForwardingHostAddressValue}set localForwardingHostAddress(e){e!==this.localForwardingHostAddressValue&&(this.localForwardingHostAddressValue=e,this.configurePortForwardingService())}get forwardedPorts(){var e;const t=null===(e=this.sshSession)||void 0===e?void 0:e.activateService(r.PortForwardingService);return null==t?void 0:t.remoteForwardedPorts}async connect(e,t,s){this.hostId=null==t?void 0:t.hostId,await this.connectTunnelSession(e,t,s)}tunnelChanged(){if(super.tunnelChanged(),this.endpoints=void 0,this.tunnel){if(!this.tunnel.endpoints)throw new Error("Tunnel endpoints cannot be null");if(0===this.tunnel.endpoints.length)throw new Error("No hosts are currently accepting connections for the tunnel.");const e=h.List.groupBy(this.tunnel.endpoints,(e=>e.hostId));if(this.hostId){if(this.endpoints=e.get(this.hostId),!this.endpoints)throw new Error("The specified host is not currently accepting connections to the tunnel.")}else{if(e.size>1)throw new Error("There are multiple hosts for the tunnel. Specify a host ID to connect to.");this.endpoints=e.entries().next().value[1]}const t=this.endpoints.filter((e=>e.connectionMode===n.TunnelConnectionMode.TunnelRelay));if(0===t.length)throw new Error("The host is not currently accepting Tunnel relay connections.");const s=t[0];this.hostPublicKeys=s.hostPublicKeys,this.relayUri=s.clientRelayUri}else this.relayUri=void 0}onRequest(e){if(e.request.requestType===r.PortForwardingService.portForwardRequestType){const t=e.request,s=new S.PortForwardingEventArgs(t.port);this.portForwardingEmitter.fire(s),e.isAuthorized=!s.cancel}else e.request.requestType===r.PortForwardingService.cancelPortForwardRequestType&&(e.isAuthorized=!0)}async configureSession(e,t,s,o){this.connectionProtocol=t,s&&this.sshSession&&!this.sshSession.isClosed?await this.sshSession.reconnect(e,o):await this.startSshSession(e,o)}startSshSession(e,s){return this.connectSession((async()=>{this.sshSession=a.SshHelpers.createSshClientSession((e=>{e.addService(r.PortForwardingService),this.connectionProtocol===t.webSocketSubProtocol?e.protocolExtensions.push(i.SshProtocolExtensionNames.sessionReconnect):e.keyExchangeAlgorithms.splice(0,0,i.SshAlgorithms.keyExchange.none)})),this.sshSession.trace=this.trace,this.sshSession.onReportProgress((e=>this.raiseReportProgress(e.progress,e.sessionNumber)),this,this.sshSessionDisposables),this.sshSession.onClosed(this.onSshSessionClosed,this,this.sshSessionDisposables),this.sshSession.onAuthenticating(this.onSshServerAuthenticating,this,this.sshSessionDisposables),this.sshSession.onDisconnected(this.onSshSessionDisconnected,this,this.sshSessionDisposables),this.sshSession.onRequest(this.onRequest,this,this.sshSessionDisposables);const o=this.sshSession.activateService(r.PortForwardingService);if(this.connectionProtocol===t.webSocketSubProtocolv2&&(o.messageFactory=this,o.onForwardedPortConnecting(this.onForwardedPortConnecting,this,this.sshSessionDisposables),o.remoteForwardedPorts.onPortAdded((e=>this.onForwardedPortAdded(o,e)),this,this.sshSessionDisposables),o.remoteForwardedPorts.onPortUpdated((e=>this.onForwardedPortAdded(o,e)),this,this.sshSessionDisposables)),this.configurePortForwardingService(),await this.sshSession.connect(e,s),this.sshSession.sessionId){const e=this.sshSession,t={username:"tunnel"};if(!await e.authenticate(t,s))throw new Error(e.principal?"SSH client authentication failed.":"SSH server authentication failed.")}}))}configurePortForwardingService(){const e=this.getSshSessionPfs();e&&(this.acceptLocalConnectionsForForwardedPortsValue&&(0,a.isNode)()?e.tcpListenerFactory=new c.RetryTcpListenerFactory(this.localForwardingHostAddressValue):e.acceptLocalConnectionsForForwardedPorts=!1)}onForwardedPortAdded(e,t){var s,o;const n=t.port.remotePort;if("number"!=typeof n)return;const r=null!==(o=null===(s=this.disconnectedStreams.get(n))||void 0===s?void 0:s.length)&&void 0!==o?o:0;for(let t=0;t<r;t++)e.connectToForwardedPort(n).then((()=>{this.trace(i.TraceLevel.Verbose,0,`Reconnected stream to fowarded port ${n}`)})).catch((e=>{this.trace(i.TraceLevel.Warning,0,`Failed to reconnect to forwarded port ${n}: ${e}`);const t=this.disconnectedStreams.get(n);if(t)for(;t.length>0;)t.pop().dispose()}))}onForwardedPortConnecting(e){if(e.stream.channel.openConfirmationMessage.convertTo(new l.PortRelayConnectResponseMessage).isE2EEncryptionEnabled){const t={username:"tunnel"};e.transformPromise=new Promise(((s,o)=>{var n;let r=null===(n=this.disconnectedStreams.get(e.port))||void 0===n?void 0:n.shift();r?(this.trace(i.TraceLevel.Verbose,0,`Reconnecting encrypted stream for port ${e.port}...`),r.reconnect(e.stream).then((()=>{this.trace(i.TraceLevel.Verbose,0,`Reconnecting encrypted stream for port ${e.port} succeeded.`),s(r)})).catch(o)):(r=new i.SecureStream(e.stream,t),r.trace=this.trace,r.onAuthenticating((e=>e.authenticationPromise=this.onHostAuthenticating(e).catch())),r.onDisconnected((()=>this.onSecureStreamDisconnected(e.port,r))),r.connect().then((()=>s(r))).catch(o))}))}super.onForwardedPortConnecting(e)}onSecureStreamDisconnected(e,t){this.trace(i.TraceLevel.Verbose,0,`Encrypted stream for port ${e} disconnected.`);const s=this.disconnectedStreams.get(e);s?s.push(t):this.disconnectedStreams.set(e,[t])}async onHostAuthenticating(e){var t,s;if(e.authenticationType!==i.SshAuthenticationType.serverPublicKey||!e.publicKey)return this.traceWarning("Invalid host authenticating event."),null;const o=null!==(s=null===(t=await e.publicKey.getPublicKeyBytes(e.publicKey.keyAlgorithmName))||void 0===t?void 0:t.toString("base64"))&&void 0!==s?s:"";return this.hostPublicKeys?this.hostPublicKeys.includes(o)?(this.traceVerbose(`Verified host identity with public key ${o}`),{}):!this.disposeToken.isCancellationRequested&&await this.refreshTunnel(!1,this.disposeToken)&&this.hostPublicKeys.includes(o)?(this.traceVerbose("Verified host identity with public key "+o),{}):(this.traceError("Host public key verification failed."),this.traceVerbose(`Host key: ${o}`),this.traceVerbose(`Expected key(s): ${this.hostPublicKeys.join(", ")}`),null):(this.traceWarning("Host identity could not be verified because no public keys were provided."),this.traceVerbose(`Host key: ${o}`),{})}onSshServerAuthenticating(e){this.connectionProtocol===t.webSocketSubProtocol?e.authenticationPromise=this.onHostAuthenticating(e):e.authenticationPromise=Promise.resolve({})}async connectToForwardedPort(e,t){const s=this.getSshSessionPfs();if(!s)throw new Error("Failed to connect to remote port. Ensure that the client has connected by calling connectClient.");return s.connectToForwardedPort(e,t)}async waitForForwardedPort(e,t){const s=this.getSshSessionPfs();if(!s)throw new Error("Port forwarding has not been started. Ensure that the client has connected by calling connectClient.");this.trace(i.TraceLevel.Verbose,0,"Waiting for forwarded port "+e),await s.waitForForwardedPort(e,t),this.trace(i.TraceLevel.Verbose,0,"Forwarded port "+e+" is ready.")}getSshSessionPfs(){var e,t;return null!==(t=null===(e=this.sshSession)||void 0===e?void 0:e.getService(r.PortForwardingService))&&void 0!==t?t:void 0}async refreshPorts(){if(!this.sshSession||this.sshSession.isClosed)throw new Error("Not connected.");const e=new i.SessionRequestMessage;e.requestType="RefreshPorts",e.wantReply=!0,await this.sshSession.request(e)}async closeSession(e,t){this.isSshSessionActive&&this.sshSessionClosedEmitter.fire(this),await super.closeSession(e,t)}onSshSessionClosed(e){this.sshSessionClosedEmitter.fire(this),super.onSshSessionClosed(e)}onSshSessionDisconnected(){this.sshSessionClosedEmitter.fire(this);const e=i.SshDisconnectReason.connectionLost,t=new i.SshConnectionError("Connection lost.",i.SshDisconnectReason.connectionLost);this.maybeStartReconnecting(e,void 0,t)}async connectClientToRelayServer(e,t){if(!e)throw new Error("Client relay URI must be a non-empty string");this.relayUri=e,this.accessToken=t,await this.connectTunnelSession()}}t.TunnelRelayTunnelClient=g,g.webSocketSubProtocol=t.webSocketSubProtocol,g.webSocketSubProtocolv2=t.webSocketSubProtocolv2}}]);