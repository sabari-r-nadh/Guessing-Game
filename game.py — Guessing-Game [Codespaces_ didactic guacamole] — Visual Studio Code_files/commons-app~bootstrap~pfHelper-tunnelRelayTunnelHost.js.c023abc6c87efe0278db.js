"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[36],{31152:(e,s,n)=>{var t=n(88538);Object.defineProperty(s,"__esModule",{value:!0}),s.TunnelRelayTunnelHost=void 0;const o=n(5037),i=n(81644),r=n(67322),a=n(10712),c=n(33717),h=n(83157),l=n(99248),d=n(11644),u=n(74668),p=n(10712),S=n(48577),w="tunnel-relay-host",P="tunnel-relay-host-v2-dev",y=(null==t?void 0:t.env)&&t.env.DEVTUNNELS_PROTOCOL_VERSION,f="1"===y?[w]:"2"===y?[P]:[P,w];class g extends S.TunnelConnectionSession{constructor(e,s){super(o.TunnelAccessScopes.Host,f,s,e),this.clientSessionPromises=[],this.reconnectableSessions=[],this.sshSessions=[],this.remoteForwarders=new Map,this.loopbackIp="127.0.0.1",this.forwardConnectionsToLocalPortsValue=(0,p.isNode)();const n=i.SshAlgorithms.publicKey.ecdsaSha2Nistp384;n&&(this.hostPrivateKeyPromise=n.generateKeyPair()),this.hostId=c.MultiModeTunnelHost.hostId,this.id=(0,u.v4)()+"-relay"}get forwardConnectionsToLocalPorts(){return this.forwardConnectionsToLocalPortsValue}set forwardConnectionsToLocalPorts(e){if(e!==this.forwardConnectionsToLocalPortsValue){if(e&&!(0,p.isNode)())throw new Error("Cannot forward connections to local TCP sockets on this platform.");this.forwardConnectionsToLocalPortsValue=e}}async start(e){await this.connect(e)}async connect(e,s,n){await this.connectTunnelSession(e,s,n)}async connectTunnelSession(e,s,n){if(this.disconnectReason===i.SshDisconnectReason.tooManyConnections)throw new i.SshConnectionError("Cannot retry connection because another host for this tunnel has connected. Only one host connection at a time is supported.",i.SshDisconnectReason.tooManyConnections);await super.connectTunnelSession(e,s,n)}async configureSession(e,s,n,t){let o;if(this.connectionProtocol=s,this.connectionProtocol===w)o=new i.SshClientSession(new i.SshSessionConfiguration(!1));else{o=a.SshHelpers.createSshClientSession((e=>{e.keyExchangeAlgorithms.splice(0,0,i.SshAlgorithms.keyExchange.none),e.addService(r.PortForwardingService)}));const e=o.activateService(r.PortForwardingService);e.messageFactory=this,e.onForwardedPortConnecting(this.onForwardedPortConnecting,this,this.sshSessionDisposables)}o.onChannelOpening(this.hostSession_ChannelOpening,this,this.sshSessionDisposables),o.onClosed(this.onSshSessionClosed,this,this.sshSessionDisposables),o.trace=this.trace,o.onReportProgress((e=>this.raiseReportProgress(e.progress,e.sessionNumber)),this,this.sshSessionDisposables),this.sshSession=o,await o.connect(e,t),o.sessionId&&await o.authenticate({username:"tunnel"}),this.connectionProtocol===P&&await this.startForwardingExistingPorts(o)}async onConnectingToTunnel(){var e,s,n,t,i;if(!this.hostPrivateKey||!this.hostPublicKeys){if(!this.hostPrivateKeyPromise)throw new Error("Cannot create host keys");this.hostPrivateKey=await this.hostPrivateKeyPromise;const e=await this.hostPrivateKey.getPublicKeyBytes(this.hostPrivateKey.keyAlgorithmName);if(!e)throw new Error("Host private key public key bytes is not initialized");this.hostPublicKeys=[e.toString("base64")]}const r=null!=(null===(e=this.tunnel)||void 0===e?void 0:e.ports)&&this.tunnel.ports.find((e=>e.protocol===o.TunnelProtocol.Ssh)),a=`${null===(s=this.tunnel)||void 0===s?void 0:s.tunnelId}.${null===(n=this.tunnel)||void 0===n?void 0:n.clusterId}:${null===(t=this.tunnel)||void 0===t?void 0:t.name}.${null===(i=this.tunnel)||void 0===i?void 0:i.domain}:${r}:${this.hostId}:${this.hostPublicKeys}`;if(!this.relayUri||this.endpointSignature!==a){if(!this.tunnel)throw new Error("Tunnel is required");let e,s={id:this.id,hostId:this.hostId,hostPublicKeys:this.hostPublicKeys,connectionMode:o.TunnelConnectionMode.TunnelRelay};r&&(e={includeSshGatewayPublicKey:"true"}),s=await this.managementClient.updateTunnelEndpoint(this.tunnel,s,{additionalQueryParameters:e}),this.relayUri=s.hostRelayUri,this.endpointSignature=a}}async dispose(){await super.dispose();const e=Object.assign([],this.clientSessionPromises);if(this.clientSessionPromises.length=0,this.tunnel&&this.endpointSignature&&this.disconnectReason!==i.SshDisconnectReason.tooManyConnections){const s=this.managementClient.deleteTunnelEndpoints(this.tunnel,this.id);e.push(s)}for(const e of this.remoteForwarders.values())e.dispose();await Promise.all(e)}hostSession_ChannelOpening(e){if(!e.isRemoteRequest)return;if(this.connectionProtocol===P&&"forwarded-tcpip"===e.channel.channelType){const s=e.channel.openMessage.convertTo(new l.PortRelayConnectRequestMessage),n=new d.PortRelayConnectResponseMessage;return n.isE2EEncryptionEnabled=this.enableE2EEncryption&&s.isE2EEncryptionRequested,void(e.openingPromise=Promise.resolve(n))}if(e.channel.channelType!==g.clientStreamChannelType)return e.failureDescription=`Unknown channel type: ${e.channel.channelType}`,void(e.failureReason=i.SshChannelOpenFailureReason.unknownChannelType);if(e.channel.maxWindowSize=5*i.SshChannel.defaultMaxWindowSize,this.isDisposed)return e.failureDescription="The host is disconnecting.",void(e.failureReason=i.SshChannelOpenFailureReason.connectFailed);const s=this.acceptClientSession(e.channel,this.disposeToken);this.clientSessionPromises.push(s),s.then((()=>{const e=this.clientSessionPromises.indexOf(s);this.clientSessionPromises.splice(e,1)}))}onForwardedPortConnecting(e){const s=e.stream.channel,n=s.openMessage.convertTo(new l.PortRelayConnectRequestMessage);if(this.enableE2EEncryption&&n.isE2EEncryptionRequested){s.maxWindowSize=2*i.SshChannel.defaultMaxWindowSize;const n={publicKeys:[this.hostPrivateKey]},t=new i.SecureStream(e.stream,n,this.reconnectableSessions);t.trace=this.trace,t.onAuthenticating((e=>e.authenticationPromise=Promise.resolve({}))),t.connect().catch((e=>{this.trace(i.TraceLevel.Error,0,`Error connecting encrypted channel: ${e}`)})),e.transformPromise=Promise.resolve(t)}super.onForwardedPortConnecting(e)}async acceptClientSession(e,s){try{const n=new i.SshStream(e);await this.connectAndRunClientSession(n,s)}catch(e){e instanceof i.CancellationError&&s.isCancellationRequested||this.trace(i.TraceLevel.Error,0,`Error running client SSH session: ${e}`)}}async connectAndRunClientSession(e,s){if(s.isCancellationRequested)throw e.destroy(),new i.CancellationError;const n=a.SshHelpers.createSshServerSession(this.reconnectableSessions,(e=>{e.protocolExtensions.push(i.SshProtocolExtensionNames.sessionReconnect),e.addService(r.PortForwardingService)}));n.trace=this.trace,n.onReportProgress((e=>this.raiseReportProgress(e.progress,e.sessionNumber)),this,this.sshSessionDisposables),n.credentials={publicKeys:[this.hostPrivateKey]};const t=new i.PromiseCompletionSource,o=n.onAuthenticating((e=>{this.onSshClientAuthenticating(e)}));n.onClientAuthenticated((()=>{this.onSshClientAuthenticated(n)}));const c=n.onRequest((e=>{this.onSshSessionRequest(e,n)})),h=n.onChannelOpening((e=>{this.onSshChannelOpening(e,n)})),l=n.onClosed((e=>{this.session_Closed(n,e,s),t.resolve()}));try{const o=new i.NodeStream(e);await n.connect(o),this.sshSessions.push(n),s.onCancellationRequested((e=>{t.reject(new i.CancellationError)})),await t.promise}finally{o.dispose(),c.dispose(),h.dispose(),l.dispose(),await n.close(i.SshDisconnectReason.byApplication),n.dispose()}}onSshClientAuthenticating(e){e.authenticationType===i.SshAuthenticationType.clientNone&&(e.authenticationPromise=Promise.resolve({}))}async onSshClientAuthenticated(e){this.startForwardingExistingPorts(e)}async startForwardingExistingPorts(e){var s,n;const t=e.activateService(r.PortForwardingService);t.forwardConnectionsToLocalPorts=this.forwardConnectionsToLocalPorts;for(const e of null!==(n=null===(s=this.tunnel)||void 0===s?void 0:s.ports)&&void 0!==n?n:[]){this.trace(i.TraceLevel.Verbose,0,`Forwarding port ${e.portNumber}`);try{await this.forwardPort(t,e)}catch(s){this.traceError(`Error forwarding port ${e.portNumber}: ${s}`)}}}onSshSessionRequest(e,s){"RefreshPorts"===e.requestType&&(e.responsePromise=(async()=>(await this.refreshPorts(),new i.SessionRequestSuccessMessage))())}onSshChannelOpening(e,s){if(!(e.request instanceof r.PortForwardChannelOpenMessage)){if(e.request.channelType===i.SshChannel.sessionChannelType)return;return this.trace(i.TraceLevel.Warning,0,"Rejecting request to open non-portforwarding channel."),void(e.failureReason=i.SshChannelOpenFailureReason.administrativelyProhibited)}const n=e.request;if("direct-tcpip"===n.channelType)this.tunnel.ports.some((e=>e.portNumber===n.port))||(this.trace(i.TraceLevel.Warning,0,"Rejecting request to connect to non-forwarded port:"+n.port),e.failureReason=i.SshChannelOpenFailureReason.administrativelyProhibited);else if("forwarded-tcpip"===n.channelType){const s=new r.ForwardedPortConnectingEventArgs(n.port,!1,new i.SshStream(e.channel));super.onForwardedPortConnecting(s)}else this.trace(i.TraceLevel.Warning,0,"Nonrecognized channel type "+n.channelType),e.failureReason=i.SshChannelOpenFailureReason.unknownChannelType}session_Closed(e,s,n){s.reason===i.SshDisconnectReason.byApplication?this.traceInfo("Client ssh session closed."):n.isCancellationRequested?this.traceInfo("Client ssh session cancelled."):s.reason!==i.SshDisconnectReason.none&&this.traceError(`Client ssh session closed unexpectedly due to ${s.reason}, "${s.message}"\n${s.error}`);for(const[s,n]of this.remoteForwarders.entries())n.session===e&&(n.dispose(),this.remoteForwarders.delete(s));const t=this.sshSessions.indexOf(e);t>=0&&this.sshSessions.splice(t,1)}async refreshPorts(e){var s,n;if(this.raiseReportProgress(o.TunnelProgress.StartingRefreshPorts),!await this.refreshTunnel(!0,e))return;const t=null!==(n=null===(s=this.tunnel)||void 0===s?void 0:s.ports)&&void 0!==n?n:[];let i=this.sshSessions;this.connectionProtocol===P&&this.sshSession&&(i=[...i,this.sshSession]);const a=[];for(const e of t)for(const s of i.filter((e=>e.isConnected&&(!e.sessionId||e.principal)))){const n=new h.SessionPortKey(s.sessionId,Number(e.portNumber));if(!this.remoteForwarders.get(n.toString())){const n=s.getService(r.PortForwardingService);a.push(this.forwardPort(n,e))}}for(const[e,s]of Object.entries(this.remoteForwarders))t.some((e=>e.portNumber===s.localPort))||(this.remoteForwarders.delete(e),s.dispose());await Promise.all(a),this.raiseReportProgress(o.TunnelProgress.CompletedRefreshPorts)}async forwardPort(e,s){const n=Number(s.portNumber);if(e.localForwardedPorts.find((e=>e.localPort===n)))return;const t=await e.forwardFromRemotePort(this.loopbackIp,n,"localhost",n);if(!t)return;const o=new h.SessionPortKey(e.session.sessionId,Number(t.localPort));this.remoteForwarders.set(o.toString(),t)}}s.TunnelRelayTunnelHost=g,g.webSocketSubProtocol=w,g.webSocketSubProtocolv2=P,g.clientStreamChannelType="client-ssh-session-stream"}}]);